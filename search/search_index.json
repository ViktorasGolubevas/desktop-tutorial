{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prad\u017eia","text":"<p>Naujienos (Atnaujinta: 2026-02-04)</p> <ul> <li>\u012ekelta x-ios paskaitos med\u017eiaga apie Rodykles.</li> <li>Pratyb\u0173 u\u017eduotis Nr. 1 jau pasiekiama Moodle.</li> </ul>"},{"location":"#programavimas-c-1-kursas","title":"Programavimas C++ (1 kursas)","text":"<p>Sveiki atvyk\u0119 \u012f objektinio programavimo C++ kalba kurs\u0105. \u0160ioje svetain\u0117je rasite vis\u0105 paskait\u0173 konspekt\u0105, kodo pavyzd\u017eius ir pratyb\u0173 u\u017eduotis.</p> <p>Organizacin\u0117 informacija</p> <ul> <li>Paskaitos: Pirmadieniais 10:00 (101 aud.)</li> <li>Pratybos: Tre\u010diadieniais 14:00 (202 aud. / Teams)</li> <li>Egzaminas: 2026-01-XX</li> <li>Moodle: Nuoroda \u012f kurs\u0105</li> </ul>"},{"location":"#naudingi-irankiai","title":"\ud83d\udee0\ufe0f Naudingi \u012frankiai","text":"<p>\u0160iuos \u012frankius naudosime viso kurso metu. Rekomenduoju i\u0161sisaugoti.</p> <p>Compiler Explorer (Godbolt){ .md-button .md-button--primary } C++ Reference{ .md-button } C++ Insights{ .md-button } Python Tutor (Vizualizacija){ .md-button }</p>"},{"location":"#vertinimo-sistema","title":"\ud83d\udcca Vertinimo sistema","text":"<p>Galutinis pa\u017eymys susideda i\u0161 kaupiamojo balo:</p> Dalis Svoris Apra\u0161ymas Laboratoriniai darbai 40% 3 gynimai semestro metu Kontrolinis (Kolokviumas) 20% Teorija ir praktin\u0117s u\u017eduotys (C dalis) Egzaminas 40% Objektinis programavimas ir STL <p>Svarbu</p> <p>Norint b\u016bti prileistam prie egzamino, privaloma atsiskaityti visus laboratorinius darbus.</p>"},{"location":"#kurso-struktura","title":"\ud83d\uddfa\ufe0f Kurso strukt\u016bra","text":"<p>Kursas suskirstytas \u012f tris loginius etapus. Detal\u0173 turin\u012f matote kair\u0117je meniu juostoje.</p>"},{"location":"#1-nuo-c-link-c-procedurinis-pagrindas","title":"1. Nuo C link C++ (Proced\u016brinis pagrindas)","text":"<p>Prisiminsime C kalb\u0105, rodykles (pointers), atminties valdym\u0105 ir pereisime prie C++ sintaks\u0117s pagerinim\u0173 (references, overload, namespace).</p>"},{"location":"#2-objektinis-programavimas-oop","title":"2. Objektinis Programavimas (OOP)","text":"<p>Pagrindin\u0117 kurso dalis. Klas\u0117s, inkapsuliacija, <code>Stack</code> evoliucija, konstruktoriai/destruktoriai, Rule of Three/Five, paveld\u0117jimas ir polimorfizmas.</p>"},{"location":"#3-stl-ir-modern-c","title":"3. STL ir Modern C++","text":"<p>Susipa\u017einsime su standartine biblioteka (<code>std::vector</code>, <code>std::map</code>), algoritmais ir i\u0161maniosiomis rodykl\u0117mis (<code>smart pointers</code>).</p> <p>Kaip naudotis \u0161ia med\u017eiaga</p> <ul> <li>Kodo pavyzd\u017eiuose naudokite vir\u0161uje esan\u010dius Skirtukus (Tabs), kad palygintum\u0117te sprendimus.</li> <li>Matydami ikon\u0105 \ud83d\ude80, spauskite j\u0105, kad atidarytum\u0117te kod\u0105 nar\u0161ykl\u0117je.</li> </ul>"},{"location":"design/","title":"Dizainas","text":""},{"location":"design/#stack-realizacijos-palyginimas","title":"Stack realizacijos palyginimas","text":"1 Etapas: C stilius6 Etapas: C++ Klas\u011710 Etapas: Modern C++ <pre><code>// Global\u016bs kintamieji\nchar stack[10];\nint top = 0;\n\nvoid push(char c) {\n    stack[top++] = c;\n}\n</code></pre> <pre><code>class Stack {\nprivate:\n    char stack[10];\n    int top;\npublic:\n    void push(char c) {\n        stack[top++] = c;\n    }\n};\n</code></pre> <pre><code>#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass Stack {\n    std::vector&lt;T&gt; data;\npublic:\n    void push(T item) {\n        data.push_back(item);\n    }\n};\n</code></pre>"},{"location":"design/#rodykliu-masyvo-struktura","title":"Rodykli\u0173 masyvo strukt\u016bra","text":"<pre><code>graph TD\n    M[Main Funkcija] --&gt;|Kuria| Arr[Rodykli\u0173 Masyvas]\n    Arr -- [0] --&gt; S1(Student Objektas)\n    Arr -- [1] --&gt; S2(Student Objektas)\n    Arr -- [2] --&gt; GS(GraduateStudent Objektas)\n\n    style GS fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"design/#admonitions-perspejimai","title":"Admonitions (Persp\u0117jimai)","text":"<p>Da\u017ena klaida: Object Slicing</p> <p>Jei priskirsite <code>GraduateStudent</code> objekt\u0105 \u012f <code>Student</code> kintam\u0105j\u012f (ne rodykl\u0119), papildomi duomenys bus nupjauti!</p> <pre><code>    Student s = GraduateStudent(\"Jonas\"); // Blogai!\n</code></pre> <p>Patarimas</p> <p>Visada naudokite <code>std::vector</code> vietoj <code>new[]</code> masyv\u0173, nebent turite labai specifin\u0119 prie\u017east\u012f.</p> <p>Pastaba</p> <p>note, kad jums ir tada reikia naudoti <code>new[]</code> masyv\u0173.</p> <p>Informacija</p> <p>info, kad jums ir tada reikia naudoti <code>new[]</code> masyv\u0173.</p>"},{"location":"betterc/ParamPass/","title":"Parametr\u0173 perdavimo mechanizmai","text":""},{"location":"betterc/ParamPass/#value-vs-pointer-vs-reference","title":"Value vs. Pointer vs. Reference","text":""},{"location":"betterc/ParamPass/#1-perdavimas-pagal-reiksme-callpass-by-value","title":"1. Perdavimas pagal reik\u0161m\u0119 (call/pass by value)","text":"<p>Tai vienintelis \"tikras\" C kalbos mechanizmas.</p> <ul> <li>\u012e funkcij\u0105 perduodamos kopijos.</li> <li>Funkcija turi savo lokalius kintamuosius (<code>temp</code>, <code>x</code>, <code>y</code>).</li> <li>Original\u016bs kintamieji <code>main</code> funkcijoje N\u0116RA kei\u010diami.</li> </ul>  Tai saugu, bet neefektyvu dideliems objektams ir netinka, kai norime pakeisti original\u0105.  <pre><code>void swap_val(int x, int y) { // Gauna KOPIJAS (x=1, y=2)\n    int temp = x;\n    x = y;\n    y = temp;\n} // \u010cia kopijos sunaikinamos. Originalai a ir b nepakito.\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"betterc/ParamPass/#2-c-rodyklemis-imituojamas-perdavimas-pagal-nuoroda-callpass-by-reference","title":"2. C rodykl\u0117mis imituojamas perdavimas pagal nuorod\u0105 (\"call/pass by reference\")","text":"<p>C kalboje nor\u0117dami pakeisti original\u0105, turime \"gudrauti\" naudodami adresus.</p> <ol> <li>Parametrai tampa rodykl\u0117mis (<code>int*</code>).</li> <li>Naudojame i\u0161adresavimo (dereference) operatori\u0173 <code>*</code>, kad pasiektume reik\u0161m\u0119.</li> <li>Kvie\u010diant funkcij\u0105, siun\u010diame adresus (<code>&amp;a</code>).</li> </ol> <pre><code>void swap_ptr(int* x, int* y) { // Gauna ADRESUS\n    int temp = *x; // Paimk reik\u0161m\u0119 i\u0161 adreso x\n    *x = *y;       // \u012era\u0161yk y reik\u0161m\u0119 \u012f x adres\u0105\n    *y = temp;     // \u012era\u0161yk temp \u012f y adres\u0105\n}\n\n// Kvietimas: swap_ptr(&amp;a, &amp;b);\n</code></pre> <p>\ud83d\udc49 Vizualizuoti atmint\u012f (Python Tutor)</p>"},{"location":"betterc/ParamPass/#3-c-perdavimas-pagal-nuorodas-callpass-by-reference","title":"3. C++ perdavimas pagal nuorodas (call/pass by reference)","text":"<p>C++ \u012fveda tikr\u0105j\u012f perdavim\u0105 pagal nuorod\u0105. Nuoroda (<code>int&amp;</code>) \u2013 tai pseudonimas (alias). Tai lyg antras vardas tam pa\u010diam kintamajam.</p> <ul> <li>Sintaks\u0117 \u0161varesn\u0117 (nereikia <code>*</code> ir <code>&amp;</code> funkcijos viduje).</li> <li>Kompiliatorius u\u017etikrina, kad nuoroda visada \u012f ka\u017ek\u0105 rodyt\u0173.</li> </ul> <pre><code>void swap_cpp(int&amp; x, int&amp; y) { // x yra 'a' pseudonimas\n    int temp = x;\n    x = y;         // Kei\u010dia pat\u012f original\u0105\n    y = temp;\n}\n\n// Kvietimas: swap_cpp(a, b);  &lt;- Atrodo paprastai!\n</code></pre> <p>\ud83d\udc49 I\u0161bandyti kode (Godbolt)</p>"},{"location":"betterc/ParamPass/#apibendrinimas-3-budai","title":"Apibendrinimas: 3 b\u016bdai","text":"Savyb\u0117 By Value (C/C++) Pointer (C stilius) Reference (C++ stilius) Deklaracija <code>void f(int x)</code> <code>void f(int* x)</code> <code>void f(int&amp; x)</code> Kvietimas <code>f(a)</code> <code>f(&amp;a)</code> <code>f(a)</code> Veiksmas Dirba su kopija Dirba su adresu Dirba su originalu Sintaks\u0117 Paprasta Sud\u0117tinga (<code>*</code>, <code>&amp;</code>) Paprasta Verdiktas Saugus, bet \"lokalus\" Galingas, bet pavojingas Modernus standartas <p><pre><code>// Tik C++ leid\u017eia ra\u0161yti taip \u0161variai:\nint main() {\n    int a=1, b=2;\n    swap_cpp(a, b); // a=2, b=1\n}\n</code></pre> ```</p>"},{"location":"betterc/ParamPass/#kodel-padariau-butent-taip","title":"Kod\u0117l padariau b\u016btent taip?","text":"<ol> <li>Strukt\u016bra: I\u0161skaid\u017eiau t\u0105 didel\u0119 lentel\u0119 \u012f atskiras temas. Pirmakursiai pameta d\u0117mes\u012f, jei skaidr\u0117je per daug kodo.</li> <li>\u201eLive\u201c elementai: \u012ed\u0117jau nuorod\u0105 \u012f Python Tutor prie pointeri\u0173 dalies.<ul> <li>Kod\u0117l? J\u016bs\u0173 PDF'e buvo tekstas \u201eparametr\u0173-reik\u0161mi\u0173 tipus padarome rodykliniais...\u201c. Tai labai sunkus sakinys. Python Tutor parodys rodykl\u0119 (arrow) grafi\u0161kai \u2013 tai pakei\u010dia 10 minu\u010di\u0173 ai\u0161kinimo.</li> </ul> </li> <li>Lentel\u0117: Paskutin\u0117je skaidr\u0117je (<code>Apibendrinimas</code>) panaudojau Markdown lentel\u0119, kuri atstoja j\u016bs\u0173 Word lentel\u0119, bet yra \u0161varesn\u0117. I\u0161\u0117miau piln\u0105 kodo realizacij\u0105 i\u0161 lentel\u0117s (nes ji jau buvo aptarta anks\u010diau), palikau tik esminius skirtumus (sintaks\u0119).</li> </ol>"},{"location":"betterc/ParamPass/#kaip-tai-pateikti-auditorijai","title":"Kaip tai pateikti auditorijai?","text":"<ol> <li>Parodote 1 skaidr\u0119 (Value). Klausiate: \u201eKod\u0117l <code>a</code> ir <code>b</code> nepasikeit\u0117?\u201c.</li> <li>Parodote 2 skaidr\u0119 (Pointer). Paspaud\u017eiate nuorod\u0105 \u012f Python Tutor. Parodote, kaip rodykl\u0117 nukreipta \u012f <code>a</code>.</li> <li>Parodote 3 skaidr\u0119 (Reference). Akcentuojate: \u201eTai veikia taip pat kaip pointeris, bet atrodo gra\u017eiai\u201c.</li> <li>Parodote 4 skaidr\u0119 (Lentel\u0119). Tai j\u016bs\u0173 \u201eCheat Sheet\u201c studentams.</li> </ol> <p>Tai puikus pavyzdys, kaip 25 met\u0173 senumo teising\u0105 in\u017einerin\u0119 mint\u012f perkelti \u012f 2024-\u0173j\u0173 format\u0105.</p>"},{"location":"evolution/array-evoliucija/","title":"Objekt\u0173 masyv\u0173 evoliucija C++: Nuo C masyv\u0173 iki STL konteineri\u0173","text":""},{"location":"evolution/array-evoliucija/#ivadas-kodel-objektu-masyvai-sudetingi","title":"\u012evadas: Kod\u0117l objekt\u0173 masyvai sud\u0117tingi?","text":"<p>Objekt\u0173 masyvai C++ kalboje yra viena i\u0161 sud\u0117tingiausi\u0173 tem\u0173, nes \u010dia susipina:</p> <ul> <li>Atminties valdymas (stekas vs heap)</li> <li>Objekt\u0173 gyvavimo ciklas (konstruktoriai/destruktoriai)</li> <li>Rodykli\u0173 semantika (rodykl\u0117 \u012f masyv\u0105 vs rodykli\u0173 masyvas)</li> <li>Polimorfizmas (virtual\u016bs metodai masyvo elementams)</li> <li>STL abstrakcijos (array, vector, smart_ptr)</li> </ul> <p>\u0160is vadovas naudoja evoliucin\u012f metod\u0105 - kiekvienas etapas sprend\u017eia ankstesnio problemas ir pristato nauj\u0105 koncept\u0105.</p>"},{"location":"evolution/array-evoliucija/#1-etapas-c-stiliaus-masyvai-su-objektais","title":"1 etapas: C stiliaus masyvai su objektais","text":""},{"location":"evolution/array-evoliucija/#koncepcija","title":"Koncepcija","text":"<p>Pradedame nuo papras\u010diausio - C stiliaus masyv\u0173 su objektais. \u010cia i\u0161kart matome pirm\u0105sias problemas.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_1.cpp - C stiliaus masyvas su objektais\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass Student {\npublic:\n    char name[50];\n    int age;\n    double grade;\n\n    // Konstruktorius\n    Student() {\n        strcpy(name, \"Unknown\");\n        age = 0;\n        grade = 0.0;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius\n    Student(const char* n, int a, double g) {\n        strcpy(name, n);\n        age = a;\n        grade = g;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== C stiliaus masyvas su objektais ===\\n\";\n\n    // \ud83d\udca5 PROBLEMA #1: Tik default konstruktorius!\n    Student students[3];  // Visi objektai sukurti su default konstruktoriumi\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // Reikia rankiniu b\u016bdu keisti duomenis\n    strcpy(students[0].name, \"Jonas\");\n    students[0].age = 20;\n    students[0].grade = 8.5;\n\n    strcpy(students[1].name, \"Petras\");\n    students[1].age = 21;\n    students[1].grade = 9.0;\n\n    strcpy(students[2].name, \"Marija\");\n    students[2].age = 19;\n    students[2].grade = 8.8;\n\n    std::cout &lt;&lt; \"\\n--- Po duomen\u0173 keitimo ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // \ud83d\udca5 PROBLEMA #2: Negalima perduoti \u012f funkcij\u0105 kaip objekto\n    // void process_students(Student students[3]) - neteisingas tipas!\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;  // \u010cia i\u0161kvie\u010diami destruktoriai\n}\n</code></pre> <p>Rezultatas: <pre><code>=== C stiliaus masyvas su objektais ===\n\ud83d\udcda Student konstruktorius: Unknown\n\ud83d\udcda Student konstruktorius: Unknown\n\ud83d\udcda Student konstruktorius: Unknown\n\n--- Pradinis masyvas ---\nStudent: Unknown, Age: 0, Grade: 0\nStudent: Unknown, Age: 0, Grade: 0\nStudent: Unknown, Age: 0, Grade: 0\n\n--- Po duomen\u0173 keitimo ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Destruktoriai ---\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#problemos-analize","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kkinimas Pasekm\u0117s Tik default konstruktorius <code>Student arr[3]</code> kvie\u010dia tik default konstruktori\u0173 Reikia rankiniu b\u016bdu keisti duomenis Masyvo tipo painiava <code>Student arr[3]</code> vs <code>Student* arr</code> Neteisingas funkcij\u0173 parametr\u0173 tipas N\u0117ra inicializacijos kontrol\u0117s Negalima sukurti su konkre\u010diais duomenimis Dvigubas darbas: sukurti + keisti C stiliaus stringai <code>char name[50]</code> + <code>strcpy</code> Nesaugus, riboto dyd\u017eio"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti, kad objekt\u0173 masyvas kvie\u010dia konstruktorius</li> <li>Matyti C stiliaus masyv\u0173 apribojimus</li> <li>Pa\u017einti destruktori\u0173 i\u0161kvietimo tvark\u0105 (atvirk\u0161\u010diai)</li> </ul>"},{"location":"evolution/array-evoliucija/#2-etapas-inicializacijos-sarasas-c11","title":"2 etapas: Inicializacijos s\u0105ra\u0161as (C++11)","text":""},{"location":"evolution/array-evoliucija/#koncepcija_1","title":"Koncepcija","text":"<p>C++11 \u012fved\u0117 inicializacijos s\u0105ra\u0161us, kurie leid\u017eia sukurti masyv\u0105 su konkre\u010diais duomenimis.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_1","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_2.cpp - Inicializacijos s\u0105ra\u0161as\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    // Default konstruktorius\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Copy konstruktorius\n    Student(const Student&amp; other) \n        : name(other.name), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\udccb Copy konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    const std::string&amp; get_name() const { return name; }\n};\n\n// Funkcija, kuri priima masyv\u0105\nvoid print_students(const Student students[], int count) {\n    std::cout &lt;&lt; \"\\n--- Funkcijoje print_students ---\\n\";\n    for (int i = 0; i &lt; count; i++) {\n        students[i].print();\n    }\n}\n\n// \ud83d\udca5 PROBLEMA: Neteisingas masyvo perdavimas\nvoid wrong_function(Student students[3]) {  // I\u0161 tikr\u0173j\u0173 Student*\n    std::cout &lt;&lt; \"sizeof(students) = \" &lt;&lt; sizeof(students) &lt;&lt; std::endl;  // 8 bytes (pointer)\n    std::cout &lt;&lt; \"Tikrasis sizeof(Student[3]) = \" &lt;&lt; sizeof(Student) * 3 &lt;&lt; std::endl;\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Inicializacijos s\u0105ra\u0161as ===\\n\";\n\n    // \u2705 C++11 inicializacijos s\u0105ra\u0161as\n    Student students[] = {\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8)\n    };\n\n    const int count = sizeof(students) / sizeof(students[0]);\n    std::cout &lt;&lt; \"Masyvo dydis: \" &lt;&lt; count &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (int i = 0; i &lt; count; i++) {\n        students[i].print();\n    }\n\n    // Funkcijos i\u0161kvietimas\n    print_students(students, count);\n\n    // Masyvo tipo demonstracija\n    std::cout &lt;&lt; \"\\n--- Masyvo tipo problema ---\\n\";\n    std::cout &lt;&lt; \"sizeof(students) main'e = \" &lt;&lt; sizeof(students) &lt;&lt; std::endl;\n    wrong_function(students);\n\n    // \ud83d\udca5 PROBLEMA: Negalima keisti masyvo dyd\u017eio\n    // students[3] = Student(\"Ona\", 22, 7.5);  // KLAIDA!\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Inicializacijos s\u0105ra\u0161as ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\nMasyvo dydis: 3\n\n--- Pradinis masyvas ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Funkcijoje print_students ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Masyvo tipo problema ---\nsizeof(students) main'e = 96\nsizeof(students) = 8\nTikrasis sizeof(Student[3]) = 96\n\n--- Destruktoriai ---\n\ud83d\uddd1\ufe0f Destruktorius: Marija\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#pagerejimai-ir-likusios-problemos","title":"\ud83d\udd0d Pager\u0117jimai ir likusios problemos","text":"Pager\u0117jimas Likusios problemos \u2705 Inicializacija su parametrais \u274c Fiksuotas dydis compile time \u2705 std::string vietoj char[] \u274c Masyvas \"virsta\" rodykle funkcijose \u2705 Automatinis dyd\u017eio skai\u010diavimas \u274c Negalima keisti dyd\u017eio runtime"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_1","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti inicializacijos s\u0105ra\u0161\u0173 sintaks\u0119</li> <li>Matyti masyvo \"virsmo\" rodykle problem\u0105</li> <li>Pa\u017einti sizeof trik\u012f masyvo dyd\u017eiui skai\u010diuoti</li> </ul>"},{"location":"evolution/array-evoliucija/#3-etapas-dinaminiai-masyvai-newdelete","title":"3 etapas: Dinaminiai masyvai (new/delete)","text":""},{"location":"evolution/array-evoliucija/#koncepcija_2","title":"Koncepcija","text":"<p>Kai reikia keisti masyvo dyd\u012f runtime, naudojame dinamin\u012f atminties paskirstym\u0105.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_2","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_3.cpp - Dinaminiai masyvai\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    // Setter metodai dinaminiam u\u017epildymui\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n;\n        age = a;\n        grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;  // Rodykl\u0117 \u012f dinamin\u012f masyv\u0105\n    int capacity;\n    int count;\n\npublic:\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: \" &lt;&lt; capacity &lt;&lt; std::endl;\n        students = new Student[capacity];  // \ud83d\udca5 Tik default konstruktoriai!\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;  // \u2705 Automati\u0161kai i\u0161kvie\u010dia vis\u0173 objekt\u0173 destruktorius\n    }\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- Visi studentai (\" &lt;&lt; count &lt;&lt; \"/\" &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n\n    // \ud83d\udca5 PROBLEMA: N\u0117ra copy konstruktoriaus ir assignment operatoriaus\n    // Shallow copy problema!\n};\n\n// Demonstracija su funkcija\nvoid test_dynamic_array() {\n    std::cout &lt;&lt; \"\\n=== Funkcijos scope testas ===\\n\";\n\n    StudentManager manager(2);\n    manager.add_student(\"Tomas\", 22, 7.8);\n    manager.add_student(\"Ona\", 20, 9.2);\n    manager.print_all();\n\n    // manager sunaikinamas \u010dia\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Dinaminiai masyvai ===\\n\";\n\n    // Paprastas dinaminis masyvas\n    int size;\n    std::cout &lt;&lt; \"\u012eveskite student\u0173 skai\u010di\u0173: \";\n    std::cin &gt;&gt; size;\n\n    Student* students = new Student[size];  // Default konstruktoriai\n\n    // U\u017epildymas duomenimis\n    for (int i = 0; i &lt; size; i++) {\n        std::string name = \"Student\" + std::to_string(i + 1);\n        students[i].set_data(name, 20 + i, 7.0 + i * 0.5);\n    }\n\n    std::cout &lt;&lt; \"\\n--- Dinaminis masyvas ---\\n\";\n    for (int i = 0; i &lt; size; i++) {\n        students[i].print();\n    }\n\n    delete[] students;  // \u2705 Destruktoriai i\u0161kvie\u010diami\n\n    // Objekto su dinaminiu masyvu testas\n    test_dynamic_array();\n\n    // \ud83d\udca5 SHALLOW COPY PROBLEMA\n    std::cout &lt;&lt; \"\\n=== Shallow copy problema ===\\n\";\n    {\n        StudentManager manager1(2);\n        manager1.add_student(\"Originalus\", 25, 8.0);\n\n        // StudentManager manager2 = manager1;  // \ud83d\udca5 CRASH! Double delete\n        // \u0160i eilut\u0117 sukelt\u0173 crash'\u0105, nes abu objektai bandyt\u0173 i\u0161trinti t\u0105 pat\u012f masyv\u0105\n    }\n\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Dinaminiai masyvai ===\n\u012eveskite student\u0173 skai\u010di\u0173: 3\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- Dinaminis masyvas ---\nStudent: Student1, Age: 20, Grade: 7\nStudent: Student2, Age: 21, Grade: 7.5\nStudent: Student3, Age: 22, Grade: 8\n\n\ud83d\uddd1\ufe0f Destruktorius: Student3\n\ud83d\uddd1\ufe0f Destruktorius: Student2\n\ud83d\uddd1\ufe0f Destruktorius: Student1\n\n=== Funkcijos scope testas ===\n\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: 2\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- Visi studentai (2/2) ---\nStudent: Tomas, Age: 22, Grade: 7.8\nStudent: Ona, Age: 20, Grade: 9.2\n\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Ona\n\ud83d\uddd1\ufe0f Destruktorius: Tomas\n\n=== Shallow copy problema ===\n\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: 2\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Originalus\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#problemos-analize_1","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kkinimas Sprendimas Tik default konstruktoriai <code>new Student[n]</code> kvie\u010dia tik default Naudoti placement new arba vector Shallow copy Kompiliatorius sukuria shallow copy Implementuoti Rule of Three Memory leak rizika Pamir\u0161us <code>delete[]</code> - memory leak Naudoti RAII arba smart pointers Double delete Kopijavimas sukelia double delete Rule of Three arba delete copy"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_2","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti new[] ir delete[] sintaks\u0119</li> <li>Matyti shallow copy problem\u0105</li> <li>Pa\u017einti RAII princip\u0105 su dinaminiais masyvais</li> </ul>"},{"location":"evolution/array-evoliucija/#4-etapas-rule-of-three-implementacija","title":"4 etapas: Rule of Three implementacija","text":""},{"location":"evolution/array-evoliucija/#koncepcija_3","title":"Koncepcija","text":"<p>Kai klas\u0117 valdo dinaminius i\u0161teklius, reikia implementuoti Rule of Three: destruktori\u0173, copy konstruktori\u0173 ir assignment operatori\u0173.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_3","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_4.cpp - Rule of Three\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n; age = a; grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;\n    int capacity;\n    int count;\n\npublic:\n    // Konstruktorius\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: \" &lt;&lt; capacity &lt;&lt; \")\\n\";\n        students = new Student[capacity];\n    }\n\n    // 1. Destruktorius\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;\n    }\n\n    // 2. Copy konstruktorius (deep copy)\n    StudentManager(const StudentManager&amp; other) \n        : capacity(other.capacity), count(other.count) {\n        std::cout &lt;&lt; \"\ud83d\udccb StudentManager copy konstruktorius\\n\";\n\n        students = new Student[capacity];  // Naujas masyvas\n\n        // Kopijuojame duomenis\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];  // Student assignment\n        }\n    }\n\n    // 3. Assignment operatorius\n    StudentManager&amp; operator=(const StudentManager&amp; other) {\n        std::cout &lt;&lt; \"\ud83d\udcdd StudentManager assignment operatorius\\n\";\n\n        if (this == &amp;other) {  // Self-assignment apsauga\n            return *this;\n        }\n\n        // I\u0161valome sen\u0105 atmint\u012f\n        delete[] students;\n\n        // Kopijuojame nauj\u0105\n        capacity = other.capacity;\n        count = other.count;\n        students = new Student[capacity];\n\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];\n        }\n\n        return *this;\n    }\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; count &lt;&lt; \"/\" &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n\n    int get_count() const { return count; }\n};\n\n// Funkcija, kuri testuoja kopijavim\u0105\nStudentManager create_test_manager() {\n    std::cout &lt;&lt; \"\\n=== Funkcijoje create_test_manager ===\\n\";\n    StudentManager manager(3);\n    manager.add_student(\"Funkcijos studentas\", 23, 8.5);\n    return manager;  // Copy konstruktorius arba move (C++11)\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Rule of Three ===\\n\";\n\n    // Originalus objektas\n    StudentManager manager1(2);\n    manager1.add_student(\"Jonas\", 20, 8.5);\n    manager1.add_student(\"Petras\", 21, 9.0);\n    manager1.print_all();\n\n    // Copy konstruktorius testas\n    std::cout &lt;&lt; \"\\n=== Copy konstruktorius ===\\n\";\n    StudentManager manager2 = manager1;  // Copy konstruktorius\n    manager2.print_all();\n\n    // Assignment operatorius testas\n    std::cout &lt;&lt; \"\\n=== Assignment operatorius ===\\n\";\n    StudentManager manager3(1);\n    manager3.add_student(\"Marija\", 19, 8.8);\n    manager3.print_all();\n\n    manager3 = manager1;  // Assignment operatorius\n    manager3.print_all();\n\n    // Self-assignment testas\n    std::cout &lt;&lt; \"\\n=== Self-assignment testas ===\\n\";\n    manager1 = manager1;  // Turi b\u016bti saugus\n    manager1.print_all();\n\n    // Return by value testas\n    std::cout &lt;&lt; \"\\n=== Return by value testas ===\\n\";\n    StudentManager manager4 = create_test_manager();\n    manager4.print_all();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Rule of Three ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 2)\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Copy konstruktorius ===\n\ud83d\udccb StudentManager copy konstruktorius\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Assignment operatorius ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 1)\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (1/1) ---\nStudent: Marija, Age: 19, Grade: 8.8\n\n\ud83d\udcdd StudentManager assignment operatorius\n\ud83d\uddd1\ufe0f Destruktorius: Marija\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Self-assignment testas ===\n\ud83d\udcdd StudentManager assignment operatorius\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Return by value testas ===\n\n=== Funkcijoje create_test_manager ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 3)\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (1/3) ---\nStudent: Funkcijos studentas, Age: 23, Grade: 8.5\n\n=== Destruktoriai ===\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Funkcijos studentas\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#rule-of-three-analize","title":"\ud83d\udd0d Rule of Three analiz\u0117","text":"Komponentas Paskirtis Kada i\u0161kvie\u010diamas Destruktorius Atlaisvina dinamin\u0119 atmint\u012f Objekto sunaikinimas Copy konstruktorius Deep copy suk\u016brimas <code>Type obj2 = obj1;</code> Assignment operatorius Deep copy priskyrimas <code>obj2 = obj1;</code>"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_3","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Implementuoti Rule of Three</li> <li>Suprasti deep copy vs shallow copy</li> <li>Matyti self-assignment apsaugos poreik\u012f</li> </ul>"},{"location":"evolution/array-evoliucija/#5-etapas-rodykliu-masyvas-vs-masyvo-rodykle","title":"5 etapas: Rodykli\u0173 masyvas vs masyvo rodykl\u0117","text":""},{"location":"evolution/array-evoliucija/#koncepcija_4","title":"Koncepcija","text":"<p>Viena i\u0161 did\u017eiausi\u0173 painiav\u0173 - skirtumas tarp \"rodykl\u0117s \u012f masyv\u0105\" ir \"rodykli\u0173 masyvo\". Ypa\u010d svarbu polimorfiniams objektams.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_4","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_5.cpp - Rodykli\u0173 semantika\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n\npublic:\n    Student(const std::string&amp; n, int a) : name(n), age(a) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, const std::string&amp; topic) \n        : Student(n, a), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nvoid demonstrate_array_types() {\n    std::cout &lt;&lt; \"\\n=== 1. Objekt\u0173 masyvas (stekas) ===\\n\";\n\n    // Objekt\u0173 masyvas - visi objektai sukurti steke\n    Student students_array[3] = {\n        Student(\"Jonas\", 20),\n        Student(\"Petras\", 21),\n        Student(\"Marija\", 19)\n    };\n\n    std::cout &lt;&lt; \"Masyvo dydis: \" &lt;&lt; sizeof(students_array) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Vieno objekto dydis: \" &lt;&lt; sizeof(Student) &lt;&lt; \" bytes\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        students_array[i].print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 2. Rodykl\u0117 \u012f masyv\u0105 ===\\n\";\n\n    // Rodykl\u0117 \u012f masyv\u0105 - rodo \u012f vis\u0105 masyv\u0105\n    Student (*ptr_to_array)[3] = &amp;students_array;\n\n    std::cout &lt;&lt; \"ptr_to_array dydis: \" &lt;&lt; sizeof(ptr_to_array) &lt;&lt; \" bytes (rodykl\u0117)\\n\";\n    std::cout &lt;&lt; \"(*ptr_to_array) dydis: \" &lt;&lt; sizeof(*ptr_to_array) &lt;&lt; \" bytes (masyvas)\\n\";\n\n    // Prieiga per rodykl\u0119 \u012f masyv\u0105\n    for (int i = 0; i &lt; 3; i++) {\n        (*ptr_to_array)[i].print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 3. Rodykli\u0173 masyvas (stekas) ===\\n\";\n\n    // Rodykli\u0173 masyvas - masyvas rodykli\u0173\n    Student* ptr_array[3];\n    ptr_array[0] = &amp;students_array[0];\n    ptr_array[1] = &amp;students_array[1];\n    ptr_array[2] = &amp;students_array[2];\n\n    std::cout &lt;&lt; \"ptr_array dydis: \" &lt;&lt; sizeof(ptr_array) &lt;&lt; \" bytes (3 rodykl\u0117s)\\n\";\n    std::cout &lt;&lt; \"Vienos rodykl\u0117s dydis: \" &lt;&lt; sizeof(Student*) &lt;&lt; \" bytes\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        ptr_array[i]-&gt;print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 4. Dinaminis rodykli\u0173 masyvas ===\\n\";\n\n    // Dinaminis rodykli\u0173 masyvas\n    Student** dynamic_ptr_array = new Student*[3];\n    dynamic_ptr_array[0] = new Student(\"Tomas\", 22);\n    dynamic_ptr_array[1] = new Student(\"Ona\", 20);\n    dynamic_ptr_array[2] = new Student(\"Lukas\", 23);\n\n    std::cout &lt;&lt; \"dynamic_ptr_array dydis: \" &lt;&lt; sizeof(dynamic_ptr_array) &lt;&lt; \" bytes (rodykl\u0117)\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        dynamic_ptr_array[i]-&gt;print();\n    }\n\n    // I\u0161valymas\n    for (int i = 0; i &lt; 3; i++) {\n        delete dynamic_ptr_array[i];\n    }\n    delete[] dynamic_ptr_array;\n}\n\nvoid demonstrate_polymorphism() {\n    std::cout &lt;&lt; \"\\n=== POLIMORFIZMAS ===\\n\";\n\n    // \ud83d\udca5 PROBLEMA: Objekt\u0173 masyvas su polimorfizmu\n    std::cout &lt;&lt; \"\\n--- Objekt\u0173 masyvas (object slicing!) ---\\n\";\n    Student mixed_array[3] = {\n        Student(\"Jonas\", 20),\n        GraduateStudent(\"Petras\", 25, \"AI Research\"),  // \ud83d\udca5 Object slicing!\n        Student(\"Marija\", 19)\n    };\n\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; mixed_array[i].get_type() &lt;&lt; \" - \";\n        mixed_array[i].print();  // Neteisingas polimorfizmas!\n    }\n\n    // \u2705 SPRENDIMAS: Rodykli\u0173 masyvas\n    std::cout &lt;&lt; \"\\n--- Rodykli\u0173 masyvas (teisingas polimorfizmas) ---\\n\";\n    Student* polymorphic_array[3];\n    polymorphic_array[0] = new Student(\"Jonas\", 20);\n    polymorphic_array[1] = new GraduateStudent(\"Petras\", 25, \"AI Research\");\n    polymorphic_array[2] = new Student(\"Marija\", 19);\n\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; polymorphic_array[i]-&gt;get_type() &lt;&lt; \" - \";\n        polymorphic_array[i]-&gt;print();  // \u2705 Teisingas polimorfizmas!\n    }\n\n    // I\u0161valymas\n    for (int i = 0; i &lt; 3; i++) {\n        delete polymorphic_array[i];\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Rodykli\u0173 semantika ===\\n\";\n\n    demonstrate_array_types();\n    demonstrate_polymorphism();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Rodykli\u0173 semantika ===\n\n=== 1. Objekt\u0173 masyvas (stekas) ===\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\nMasyvo dydis: 96 bytes\nVieno objekto dydis: 32 bytes\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 2. Rodykl\u0117 \u012f masyv\u0105 ===\nptr_to_array dydis: 8 bytes (rodykl\u0117)\n(*ptr_to_array) dydis: 96 bytes (masyvas)\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 3. Rodykli\u0173 masyvas (stekas) ===\nptr_array dydis: 24 bytes (3 rodykl\u0117s)\nVienos rodykl\u0117s dydis: 8 bytes\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 4. Dinaminis rodykli\u0173 masyvas ===\n\ud83d\udcda Student konstruktorius: Tomas\n\ud83d\udcda Student konstruktorius: Ona\n\ud83d\udcda Student konstruktorius: Lukas\ndynamic_ptr_array dydis: 8 bytes (rodykl\u0117)\n\nStudent: Tomas, Age: 22\nStudent: Ona, Age: 20\nStudent: Lukas, Age: 23\n\n\ud83d\uddd1\ufe0f Student destruktorius: Lukas\n\ud83d\uddd1\ufe0f Student destruktorius: Ona\n\ud83d\uddd1\ufe0f Student destruktorius: Tomas\n\n=== POLIMORFIZMAS ===\n\n--- Objekt\u0173 masyvas (object slicing!) ---\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\n\nTipas: Student - Student: Jonas, Age: 20\nTipas: Student - Student: Petras, Age: 25\nTipas: Student - Student: Marija, Age: 19\n\n--- Rodykli\u0173 masyvas (teisingas polimorfizmas) ---\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\n\nTipas: Student - Student: Jonas, Age: 20\nTipas: GraduateStudent - Graduate Student: Petras, Age: 25, Thesis: AI Research\nTipas: Student - Student: Marija, Age: 19\n\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n\n=== Destruktoriai ===\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#rodykliu-semantikos-analize","title":"\ud83d\udd0d Rodykli\u0173 semantikos analiz\u0117","text":"Tipas Sintaks\u0117 Atminties vieta Polimorfizmas Naudojimas Objekt\u0173 masyvas <code>Student arr[3]</code> Stekas \u274c Object slicing Vienodo tipo objektai Rodykl\u0117 \u012f masyv\u0105 <code>Student (*ptr)[3]</code> Stekas \u274c Object slicing Retai naudojama Rodykli\u0173 masyvas <code>Student* arr[3]</code> Stekas/Heap \u2705 Veikia Polimorfizmas Dinaminis rodykli\u0173 masyvas <code>Student** arr</code> Heap \u2705 Veikia Dinaminis polimorfizmas"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_4","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Atskirti rodykl\u0119 \u012f masyv\u0105 nuo rodykli\u0173 masyvo</li> <li>Suprasti object slicing problem\u0105</li> <li>Matyti polimorfizmo poreik\u012f rodykli\u0173 masyvams</li> </ul>"},{"location":"evolution/array-evoliucija/#6-etapas-stl-stdarray","title":"6 etapas: STL std::array","text":""},{"location":"evolution/array-evoliucija/#koncepcija_5","title":"Koncepcija","text":"<p>C++11 \u012fved\u0117 <code>std::array</code> - saug\u0173 C masyv\u0173 pakaital\u0105 su STL funkcionalumu.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_5","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_6.cpp - std::array\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n\n    // Operatoriai palyginimui\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n\n    bool operator&gt;(const Student&amp; other) const {\n        return grade &gt; other.grade;\n    }\n};\n\nvoid demonstrate_std_array() {\n    std::cout &lt;&lt; \"\\n=== std::array demonstracija ===\\n\";\n\n    // \u2705 std::array su inicializacijos s\u0105ra\u0161u\n    std::array&lt;Student, 4&gt; students = {{\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8),\n        Student(\"Tomas\", 22, 7.5)\n    }};\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (const auto&amp; student : students) {  // Range-based for loop\n        student.print();\n    }\n\n    // STL algoritmai\n    std::cout &lt;&lt; \"\\n--- R\u016b\u0161iavimas pagal pa\u017eym\u012f ---\\n\";\n    std::sort(students.begin(), students.end());  // R\u016b\u0161iuoja pagal operator&lt;\n\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i + 1 &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // Paie\u0161ka\n    std::cout &lt;&lt; \"\\n--- Paie\u0161ka ---\\n\";\n    auto it = std::find_if(students.begin(), students.end(), \n        [](const Student&amp; s) { return s.get_grade() &gt; 8.7; });\n\n    if (it != students.end()) {\n        std::cout &lt;&lt; \"Rastas studentas su pa\u017eymiu &gt; 8.7: \";\n        it-&gt;print();\n    }\n\n    // Saugus prieigos metodas\n    std::cout &lt;&lt; \"\\n--- Saugi prieiga ---\\n\";\n    try {\n        std::cout &lt;&lt; \"students.at(2): \";\n        students.at(2).print();\n\n        // std::cout &lt;&lt; \"students.at(10): \";\n        // students.at(10).print();  // Mest\u0173 std::out_of_range\n    } catch (const std::out_of_range&amp; e) {\n        std::cout &lt;&lt; \"Klaida: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // Array informacija\n    std::cout &lt;&lt; \"\\n--- Array informacija ---\\n\";\n    std::cout &lt;&lt; \"Dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maksimalus dydis: \" &lt;&lt; students.max_size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Tu\u0161\u010dias: \" &lt;&lt; (students.empty() ? \"Taip\" : \"Ne\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Duomen\u0173 rodykl\u0117: \" &lt;&lt; students.data() &lt;&lt; std::endl;\n}\n\n// Funkcija, kuri priima std::array\nvoid process_students(const std::array&lt;Student, 4&gt;&amp; students) {\n    std::cout &lt;&lt; \"\\n--- Funkcijoje process_students ---\\n\";\n    std::cout &lt;&lt; \"Gauto masyvo dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n\n    double total_grade = 0.0;\n    for (const auto&amp; student : students) {\n        total_grade += student.get_grade();\n    }\n\n    std::cout &lt;&lt; \"Vidutinis pa\u017eymys: \" &lt;&lt; total_grade / students.size() &lt;&lt; std::endl;\n}\n\n// Template funkcija bet kokio dyd\u017eio array\ntemplate&lt;size_t N&gt;\nvoid print_array_info(const std::array&lt;Student, N&gt;&amp; arr) {\n    std::cout &lt;&lt; \"\\n--- Template funkcija (dydis: \" &lt;&lt; N &lt;&lt; \") ---\\n\";\n    std::cout &lt;&lt; \"Array dydis: \" &lt;&lt; arr.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pirmasis studentas: \";\n    if (!arr.empty()) {\n        arr.front().print();\n    }\n    std::cout &lt;&lt; \"Paskutinis studentas: \";\n    if (!arr.empty()) {\n        arr.back().print();\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::array ===\\n\";\n\n    demonstrate_std_array();\n\n    // Funkcijos i\u0161kvietimas\n    std::array&lt;Student, 4&gt; test_students = {{\n        Student(\"A\", 20, 8.0),\n        Student(\"B\", 21, 9.0),\n        Student(\"C\", 19, 7.0),\n        Student(\"D\", 22, 8.5)\n    }};\n\n    process_students(test_students);\n\n    // Template funkcijos testas\n    std::array&lt;Student, 2&gt; small_array = {{\n        Student(\"X\", 25, 9.5),\n        Student(\"Y\", 24, 8.9)\n    }};\n\n    print_array_info(test_students);  // N = 4\n    print_array_info(small_array);   // N = 2\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== STL std::array ===\n\n=== std::array demonstracija ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\n\ud83d\udcda Parametrinis konstruktorius: Tomas\n\n--- Pradinis masyvas ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\nStudent: Tomas, Age: 22, Grade: 7.5\n\n--- R\u016b\u0161iavimas pagal pa\u017eym\u012f ---\n1. Student: Tomas, Age: 22, Grade: 7.5\n2. Student: Jonas, Age: 20, Grade: 8.5\n3. Student: Marija, Age: 19, Grade: 8.8\n4. Student: Petras, Age: 21, Grade: 9\n\n--- Paie\u0161ka ---\nRastas studentas su pa\u017eymiu &gt; 8.7: Student: Marija, Age: 19, Grade: 8.8\n\n--- Saugi prieiga ---\nstudents.at(2): Student: Marija, Age: 19, Grade: 8.8\n\n--- Array informacija ---\nDydis: 4\nMaksimalus dydis: 4\nTu\u0161\u010dias: Ne\nDuomen\u0173 rodykl\u0117: 0x7fff5fbff040\n\n\ud83d\udcda Parametrinis konstruktorius: A\n\ud83d\udcda Parametrinis konstruktorius: B\n\ud83d\udcda Parametrinis konstruktorius: C\n\ud83d\udcda Parametrinis konstruktorius: D\n\n--- Funkcijoje process_students ---\nGauto masyvo dydis: 4\nVidutinis pa\u017eymys: 8.125\n\n\ud83d\udcda Parametrinis konstruktorius: X\n\ud83d\udcda Parametrinis konstruktorius: Y\n\n--- Template funkcija (dydis: 4) ---\nArray dydis: 4\nPirmasis studentas: Student: A, Age: 20, Grade: 8\nPaskutinis studentas: Student: D, Age: 22, Grade: 8.5\n\n--- Template funkcija (dydis: 2) ---\nArray dydis: 2\nPirmasis studentas: Student: X, Age: 25, Grade: 9.5\nPaskutinis studentas: Student: Y, Age: 24, Grade: 8.9\n\n=== Destruktoriai ===\n[Destruktori\u0173 seka...]\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#stdarray-privalumai","title":"\ud83d\udd0d std::array privalumai","text":"Funkcija C masyvas std::array Dyd\u017eio \u017einojimas <code>sizeof(arr)/sizeof(arr[0])</code> <code>arr.size()</code> Saugi prieiga \u274c N\u0117ra \u2705 <code>at()</code> metodas STL algoritmai \u274c Reikia rodykli\u0173 \u2705 <code>begin()/end()</code> Range-based for \u274c Neveikia \u2705 Veikia Funkcij\u0173 parametrai Virsta rodykle I\u0161laiko tip\u0105 Template palaikymas \u274c Sud\u0117tinga \u2705 Nat\u016bralus"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_5","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti std::array vietoj C masyv\u0173</li> <li>Taikyti STL algoritmus</li> <li>Suprasti template funkcij\u0173 privalumus</li> </ul>"},{"location":"evolution/array-evoliucija/#7-etapas-stl-stdvector","title":"7 etapas: STL std::vector","text":""},{"location":"evolution/array-evoliucija/#koncepcija_6","title":"Koncepcija","text":"<p><code>std::vector</code> - dinaminis masyvas su automati\u0161ku dyd\u017eio valdymu ir RAII principais.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_6","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_7.cpp - std::vector\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;memory&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Copy konstruktorius\n    Student(const Student&amp; other) \n        : name(other.name), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\udccb Copy konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Move konstruktorius (C++11)\n    Student(Student&amp;&amp; other) noexcept\n        : name(std::move(other.name)), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\ude9a Move konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n        other.name = \"Moved\";\n        other.age = 0;\n        other.grade = 0.0;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n};\n\nvoid demonstrate_vector_basics() {\n    std::cout &lt;&lt; \"\\n=== Vector pagrindai ===\\n\";\n\n    // Tu\u0161\u010dias vector\n    std::vector&lt;Student&gt; students;\n    std::cout &lt;&lt; \"Pradinis dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pradinis capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Prid\u0117jimas su emplace_back (C++11)\n    std::cout &lt;&lt; \"\\n--- emplace_back ---\\n\";\n    students.emplace_back(\"Jonas\", 20, 8.5);    // Konstruojama vietoje\n    students.emplace_back(\"Petras\", 21, 9.0);\n    students.emplace_back(\"Marija\", 19, 8.8);\n\n    std::cout &lt;&lt; \"Po prid\u0117jimo - dydis: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Prid\u0117jimas su push_back\n    std::cout &lt;&lt; \"\\n--- push_back ---\\n\";\n    Student temp_student(\"Tomas\", 22, 7.5);\n    students.push_back(temp_student);  // Copy\n    students.push_back(Student(\"Ona\", 20, 9.2));  // Move\n\n    std::cout &lt;&lt; \"Po push_back - dydis: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Spausdinimas\n    std::cout &lt;&lt; \"\\n--- Visi studentai ---\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i + 1 &lt;&lt; \". \";\n        students[i].print();\n    }\n}\n\nvoid demonstrate_vector_operations() {\n    std::cout &lt;&lt; \"\\n=== Vector operacijos ===\\n\";\n\n    // Inicializacija su dyd\u017eiu\n    std::vector&lt;Student&gt; students(3);  // 3 default objektai\n    std::cout &lt;&lt; \"Vector su 3 default objektais sukurtas\\n\";\n\n    // U\u017epildymas duomenimis\n    students[0] = Student(\"A\", 20, 8.0);  // Assignment\n    students[1] = Student(\"B\", 21, 9.0);\n    students[2] = Student(\"C\", 19, 7.0);\n\n    std::cout &lt;&lt; \"\\n--- Po assignment ---\\n\";\n    for (const auto&amp; student : students) {\n        student.print();\n    }\n\n    // \u012eterpimas\n    std::cout &lt;&lt; \"\\n--- Insert operacija ---\\n\";\n    auto it = students.begin() + 1;  // Antra pozicija\n    students.insert(it, Student(\"Inserted\", 23, 8.7));\n\n    std::cout &lt;&lt; \"Po insert:\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // \u0160alinimas\n    std::cout &lt;&lt; \"\\n--- Erase operacija ---\\n\";\n    students.erase(students.begin() + 2);  // \u0160aliname tre\u010di\u0105 element\u0105\n\n    std::cout &lt;&lt; \"Po erase:\\n\";\n    for (const auto&amp; student : students) {\n        student.print();\n    }\n\n    // Dyd\u017eio keitimas\n    std::cout &lt;&lt; \"\\n--- Resize operacija ---\\n\";\n    std::cout &lt;&lt; \"Prie\u0161 resize: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    students.resize(6);  // Prid\u0117s 3 default objektus\n    std::cout &lt;&lt; \"Po resize(6): \" &lt;&lt; students.size() &lt;&lt; std::endl;\n\n    students.resize(2);  // Pa\u0161alins 4 objektus\n    std::cout &lt;&lt; \"Po resize(2): \" &lt;&lt; students.size() &lt;&lt; std::endl;\n}\n\nvoid demonstrate_vector_memory() {\n    std::cout &lt;&lt; \"\\n=== Vector atminties valdymas ===\\n\";\n\n    std::vector&lt;Student&gt; students;\n    students.reserve(10);  // Rezervuojame viet\u0105 10 objekt\u0173\n\n    std::cout &lt;&lt; \"Po reserve(10) - size: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Stebime capacity poky\u010dius\n    for (int i = 0; i &lt; 15; i++) {\n        size_t old_capacity = students.capacity();\n        students.emplace_back(\"Student\" + std::to_string(i), 20 + i, 7.0 + i * 0.1);\n\n        if (students.capacity() != old_capacity) {\n            std::cout &lt;&lt; \"Capacity pakito: \" &lt;&lt; old_capacity \n                      &lt;&lt; \" -&gt; \" &lt;&lt; students.capacity() \n                      &lt;&lt; \" (size: \" &lt;&lt; students.size() &lt;&lt; \")\\n\";\n        }\n    }\n\n    // Atminties optimizacija\n    std::cout &lt;&lt; \"\\n--- Atminties optimizacija ---\\n\";\n    std::cout &lt;&lt; \"Prie\u0161 shrink_to_fit - capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n    students.shrink_to_fit();\n    std::cout &lt;&lt; \"Po shrink_to_fit - capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n}\n\n// Vector su polimorfizmu\nvoid demonstrate_polymorphic_vector() {\n    std::cout &lt;&lt; \"\\n=== Polimorfinis vector ===\\n\";\n\n    // Vector su smart pointers polimorfizmui\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; polymorphic_students;\n\n    polymorphic_students.push_back(std::make_unique&lt;Student&gt;(\"Jonas\", 20, 8.5));\n    polymorphic_students.push_back(std::make_unique&lt;Student&gt;(\"Petras\", 21, 9.0));\n\n    std::cout &lt;&lt; \"Polimorfinis vector su smart pointers:\\n\";\n    for (const auto&amp; student_ptr : polymorphic_students) {\n        student_ptr-&gt;print();\n    }\n\n    // Automatinis cleanup su unique_ptr\n    std::cout &lt;&lt; \"Smart pointers automati\u0161kai i\u0161valys atmint\u012f\\n\";\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::vector ===\\n\";\n\n    demonstrate_vector_basics();\n    demonstrate_vector_operations();\n    demonstrate_vector_memory();\n    demonstrate_polymorphic_vector();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas (sutrumpinta): <pre><code>=== STL std::vector ===\n\n=== Vector pagrindai ===\nPradinis dydis: 0\nPradinis capacity: 0\n\n--- emplace_back ---\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\nPo prid\u0117jimo - dydis: 3, capacity: 4\n\n--- push_back ---\n\ud83d\udcda Parametrinis konstruktorius: Tomas\n\ud83d\udccb Copy konstruktorius: Tomas\n\ud83d\udcda Parametrinis konstruktorius: Ona\n\ud83d\ude9a Move konstruktorius: Ona\nPo push_back - dydis: 5, capacity: 8\n\n=== Vector atminties valdymas ===\nPo reserve(10) - size: 0, capacity: 10\nCapacity pakito: 10 -&gt; 20 (size: 11)\n\n--- Atminties optimizacija ---\nPrie\u0161 shrink_to_fit - capacity: 20\nPo shrink_to_fit - capacity: 15\n\n=== Polimorfinis vector ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\nPolimorfinis vector su smart pointers:\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nSmart pointers automati\u0161kai i\u0161valys atmint\u012f\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#stdvector-privalumai","title":"\ud83d\udd0d std::vector privalumai","text":"Funkcija Dinaminis masyvas (new[]) std::vector Atminties valdymas Rankinis new[]/delete[] Automatinis RAII Dyd\u017eio keitimas Reikia perkurti <code>resize()</code>, <code>push_back()</code> Saugi prieiga \u274c N\u0117ra \u2705 <code>at()</code> metodas STL algoritmai \u274c Reikia rodykli\u0173 \u2705 Pilnas palaikymas Exception safety \u274c Memory leaks \u2705 RAII apsauga Performance Grei\u010diausias Beveik toks pat"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_6","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti std::vector vietoj dinamini\u0173 masyv\u0173</li> <li>Suprasti capacity vs size skirtumus</li> <li>Taikyti smart pointers polimorfizmui</li> </ul>"},{"location":"evolution/array-evoliucija/#8-etapas-smart-pointers-su-objektu-masyvais","title":"8 etapas: Smart pointers su objekt\u0173 masyvais","text":""},{"location":"evolution/array-evoliucija/#koncepcija_7","title":"Koncepcija","text":"<p>Modern C++ (C++11+) rekomenduoja naudoti smart pointers vietoj raw pointers, ypa\u010d objekt\u0173 masyvams su polimorfizmu.</p>"},{"location":"evolution/array-evoliucija/#kodas-ir-analize_7","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_8.cpp - Smart pointers\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;array&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, double g, const std::string&amp; topic) \n        : Student(n, a, g), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nclass StudentManager {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n\npublic:\n    StudentManager() {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius\\n\";\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        // unique_ptr automati\u0161kai i\u0161valo objektus\n    }\n\n    // Move-only semantics (unique_ptr negalima kopijuoti)\n    StudentManager(const StudentManager&amp;) = delete;\n    StudentManager&amp; operator=(const StudentManager&amp;) = delete;\n\n    // Move konstruktorius ir assignment\n    StudentManager(StudentManager&amp;&amp;) = default;\n    StudentManager&amp; operator=(StudentManager&amp;&amp;) = default;\n\n    void add_student(std::unique_ptr&lt;Student&gt; student) {\n        students.push_back(std::move(student));\n    }\n\n    template&lt;typename StudentType, typename... Args&gt;\n    void emplace_student(Args&amp;&amp;... args) {\n        students.push_back(std::make_unique&lt;StudentType&gt;(std::forward&lt;Args&gt;(args)...));\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; students.size() &lt;&lt; \" student\u0173) ---\\n\";\n        for (const auto&amp; student : students) {\n            std::cout &lt;&lt; \"Tipas: \" &lt;&lt; student-&gt;get_type() &lt;&lt; \" - \";\n            student-&gt;print();\n        }\n    }\n\n    void remove_student(size_t index) {\n        if (index &lt; students.size()) {\n            std::cout &lt;&lt; \"\u0160alinamas studentas: \" &lt;&lt; students[index]-&gt;get_name() &lt;&lt; std::endl;\n            students.erase(students.begin() + index);\n        }\n    }\n\n    size_t size() const { return students.size(); }\n};\n\nvoid demonstrate_unique_ptr() {\n    std::cout &lt;&lt; \"\\n=== unique_ptr demonstracija ===\\n\";\n\n    // Sukuriame unique_ptr objektus\n    auto student1 = std::make_unique&lt;Student&gt;(\"Jonas\", 20, 8.5);\n    auto grad_student = std::make_unique&lt;GraduateStudent&gt;(\"Petras\", 25, 9.0, \"AI Research\");\n\n    std::cout &lt;&lt; \"\\n--- Objektai sukurti ---\\n\";\n    student1-&gt;print();\n    grad_student-&gt;print();\n\n    // Perduodame ownership \u012f vector\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n    students.push_back(std::move(student1));  // student1 dabar nullptr\n    students.push_back(std::move(grad_student));\n\n    std::cout &lt;&lt; \"\\n--- Po move \u012f vector ---\\n\";\n    std::cout &lt;&lt; \"student1 yra nullptr: \" &lt;&lt; (student1 == nullptr ? \"Taip\" : \"Ne\") &lt;&lt; std::endl;\n\n    for (const auto&amp; student : students) {\n        student-&gt;print();\n    }\n\n    // Automatinis cleanup\n    std::cout &lt;&lt; \"\\n--- Vector sunaikinamas ---\\n\";\n}\n\nvoid demonstrate_shared_ptr() {\n    std::cout &lt;&lt; \"\\n=== shared_ptr demonstracija ===\\n\";\n\n    // Sukuriame shared_ptr objektus\n    auto student1 = std::make_shared&lt;Student&gt;(\"Marija\", 19, 8.8);\n    auto student2 = std::make_shared&lt;GraduateStudent&gt;(\"Tomas\", 24, 9.2, \"Machine Learning\");\n\n    std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;\n\n    // Dalijam\u0117s ownership\n    {\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group1;\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group2;\n\n        group1.push_back(student1);\n        group1.push_back(student2);\n\n        group2.push_back(student1);  // Tas pats objektas dviejuose vector'iuose\n\n        std::cout &lt;&lt; \"\\nPo prid\u0117jimo \u012f vector'ius:\\n\";\n        std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;  // 2\n        std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;  // 1\n\n        std::cout &lt;&lt; \"\\n--- group1 ---\\n\";\n        for (const auto&amp; student : group1) {\n            student-&gt;print();\n        }\n\n        std::cout &lt;&lt; \"\\n--- group2 ---\\n\";\n        for (const auto&amp; student : group2) {\n            student-&gt;print();\n        }\n\n        std::cout &lt;&lt; \"\\n--- Vector'iai sunaikinami ---\\n\";\n    }\n\n    std::cout &lt;&lt; \"\\nPo vector'i\u0173 sunaikinimo:\\n\";\n    std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;  // 1\n    std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;  // 1\n}\n\nvoid demonstrate_student_manager() {\n    std::cout &lt;&lt; \"\\n=== StudentManager su smart pointers ===\\n\";\n\n    StudentManager manager;\n\n    // Prid\u0117jimas su make_unique\n    manager.add_student(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\n    manager.add_student(std::make_unique&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"Data Science\"));\n\n    // Prid\u0117jimas su emplace\n    manager.emplace_student&lt;Student&gt;(\"C\", 21, 7.5);\n    manager.emplace_student&lt;GraduateStudent&gt;(\"D\", 26, 8.8, \"Robotics\");\n\n    manager.print_all();\n\n    // \u0160alinimas\n    std::cout &lt;&lt; \"\\n--- \u0160alinamas studentas ---\\n\";\n    manager.remove_student(1);  // \u0160aliname \"B\"\n\n    manager.print_all();\n\n    // Move semantics testas\n    std::cout &lt;&lt; \"\\n--- Move semantics ---\\n\";\n    StudentManager manager2 = std::move(manager);  // Move constructor\n\n    std::cout &lt;&lt; \"Originalus manager dydis: \" &lt;&lt; manager.size() &lt;&lt; std::endl;  // 0\n    std::cout &lt;&lt; \"Naujas manager2 dydis: \" &lt;&lt; manager2.size() &lt;&lt; std::endl;    // 3\n\n    manager2.print_all();\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Smart pointers su objekt\u0173 masyvais ===\\n\";\n\n    demonstrate_unique_ptr();\n    demonstrate_shared_ptr();\n    demonstrate_student_manager();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas (sutrumpinta): <pre><code>=== Smart pointers su objekt\u0173 masyvais ===\n\n=== unique_ptr demonstracija ===\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\n--- Objektai sukurti ---\nStudent: Jonas, Age: 20, Grade: 8.5\nGraduate Student: Petras, Age: 25, Grade: 9, Thesis: AI Research\n\n--- Po move \u012f vector ---\nstudent1 yra nullptr: Taip\nStudent: Jonas, Age: 20, Grade: 8.5\nGraduate Student: Petras, Age: 25, Grade: 9, Thesis: AI Research\n\n--- Vector sunaikinamas ---\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n\n=== shared_ptr demonstracija ===\n\ud83d\udcda Student konstruktorius: Marija\n\ud83d\udcda Student konstruktorius: Tomas\n\ud83c\udf93 GraduateStudent konstruktorius: Tomas\nstudent1 use_count: 1\nstudent2 use_count: 1\n\nPo prid\u0117jimo \u012f vector'ius:\nstudent1 use_count: 2\nstudent2 use_count: 1\n\nPo vector'i\u0173 sunaikinimo:\nstudent1 use_count: 1\nstudent2 use_count: 1\n\n=== StudentManager su smart pointers ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius\n\ud83d\udcda Student konstruktorius: A\n\ud83d\udcda Student konstruktorius: B\n\ud83c\udf93 GraduateStudent konstruktorius: B\n\ud83d\udcda Student konstruktorius: C\n\ud83d\udcda Student konstruktorius: D\n\ud83c\udf93 GraduateStudent konstruktorius: D\n\n--- StudentManager (4 student\u0173) ---\nTipas: Student - Student: A, Age: 20, Grade: 8\nTipas: GraduateStudent - Graduate Student: B, Age: 25, Grade: 9, Thesis: Data Science\nTipas: Student - Student: C, Age: 21, Grade: 7.5\nTipas: GraduateStudent - Graduate Student: D, Age: 26, Grade: 8.8, Thesis: Robotics\n\n--- \u0160alinamas studentas ---\n\u0160alinamas studentas: B\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: B\n\ud83d\uddd1\ufe0f Student destruktorius: B\n\n--- Move semantics ---\nOriginalus manager dydis: 0\nNaujas manager2 dydis: 3\n</code></pre></p>"},{"location":"evolution/array-evoliucija/#smart-pointers-palyginimas","title":"\ud83d\udd0d Smart pointers palyginimas","text":"Tipas Ownership Kopijavimas Naudojimas unique_ptr Vienasmen\u0117 \u274c Tik move Objekt\u0173 masyvai, RAII shared_ptr Bendras \u2705 Reference counting Dalijamasi objektais weak_ptr Nestiprus \u2705 Nepadidina count Cikl\u0173 vengimas"},{"location":"evolution/array-evoliucija/#mokymosi-tikslai_7","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti smart pointers vietoj raw pointers</li> <li>Suprasti unique_ptr vs shared_ptr skirtumus</li> <li>Taikyti move semantics objekt\u0173 masyvams</li> </ul>"},{"location":"evolution/array-evoliucija/#isvados-ir-rekomendacijos","title":"I\u0161vados ir rekomendacijos","text":""},{"location":"evolution/array-evoliucija/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":"Etapas Metodas Privalumai Tr\u016bkumai Kada naudoti 1. C masyvai <code>Student arr[3]</code> Paprastas Fiksuotas dydis, tik default konstruktorius Mokymosi tikslais 2. Inicializacijos s\u0105ra\u0161as <code>Student arr[] = {...}</code> Parametriniai konstruktoriai Fiksuotas dydis \u017dinomas dydis compile time 3. Dinaminiai masyvai <code>new Student[n]</code> Dinaminis dydis Manual memory management Legacy kodas 4. Rule of Three Su copy/assignment Saugus kopijavimas Sud\u0117tinga implementacija Kai reikia kopijuoti 5. Rodykli\u0173 masyvai <code>Student* arr[]</code> Polimorfizmas Manual cleanup Polimorfizmas be STL 6. std::array <code>std::array&lt;Student, N&gt;</code> STL funkcionalumas, saugumas Fiksuotas dydis \u017dinomas dydis, STL algoritmai 7. std::vector <code>std::vector&lt;Student&gt;</code> Dinaminis, RAII, STL \u0160iek tiek overhead Da\u017eniausiai naudojamas 8. Smart pointers <code>vector&lt;unique_ptr&lt;Student&gt;&gt;</code> Polimorfizmas, RAII Sud\u0117tingesn\u0117 sintaks\u0117 Modern C++ polimorfizmas"},{"location":"evolution/array-evoliucija/#praktines-rekomendacijos","title":"Praktin\u0117s rekomendacijos","text":""},{"location":"evolution/array-evoliucija/#kada-naudoti-kuri-metoda","title":"Kada naudoti kur\u012f metod\u0105:","text":"<ol> <li>std::vector - da\u017eniausiai naudojamas pasirinkimas <li>Vienodo tipo objektai</li> <li>Dinaminis dydis</li> <li> <p>STL algoritmai</p> </li> <li> <p>std::vector&gt; - polimorfizmui <li>Skirting\u0173 tip\u0173 objektai</li> <li>Virtual\u016bs metodai</li> <li> <p>Modern C++ stilius</p> </li> <li> <p>std::array - fiksuotam dyd\u017eiui <li>\u017dinomas dydis compile time</li> <li>Maksimalus performance</li> <li> <p>STL funkcionalumas</p> </li> <li> <p>C masyvai - vengti, i\u0161skyrus:</p> </li> <li>Legacy kodas</li> <li>Embedded systems</li> <li>Mokymosi tikslais</li>"},{"location":"evolution/array-evoliucija/#dazniausios-klaidos-ir-ju-vengimas","title":"Da\u017eniausios klaidos ir j\u0173 vengimas","text":""},{"location":"evolution/array-evoliucija/#1-object-slicing","title":"1. Object Slicing","text":"<pre><code>// \u274c Blogai\nStudent arr[3] = {\n    Student(\"A\", 20, 8.0),\n    GraduateStudent(\"B\", 25, 9.0, \"AI\"),  // Object slicing!\n    Student(\"C\", 19, 7.5)\n};\n\n// \u2705 Gerai\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\nstudents.push_back(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\nstudents.push_back(std::make_unique&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"AI\"));\n</code></pre>"},{"location":"evolution/array-evoliucija/#2-memory-leaks","title":"2. Memory Leaks","text":"<pre><code>// \u274c Blogai\nStudent** students = new Student*[3];\nstudents[0] = new Student(\"A\", 20, 8.0);\n// Pamir\u0161tas delete[] ir delete\n\n// \u2705 Gerai\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\nstudents.push_back(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\n// Automatinis cleanup\n</code></pre>"},{"location":"evolution/array-evoliucija/#3-shallow-copy","title":"3. Shallow Copy","text":"<pre><code>// \u274c Blogai - be Rule of Three\nclass StudentManager {\n    Student* students;\n    int count;\n    // Tr\u016bksta copy constructor ir assignment operator\n};\n\n// \u2705 Gerai - su std::vector\nclass StudentManager {\n    std::vector&lt;Student&gt; students;  // Automatinis deep copy\n};\n</code></pre>"},{"location":"evolution/array-evoliucija/#mokymosi-kelias","title":"Mokymosi kelias","text":"<ol> <li>Prad\u0117kite nuo C masyv\u0173 - suprasite problemas</li> <li>Pereikite prie std::array - saugumas + STL</li> <li>I\u0161mokite std::vector - da\u017eniausiai naudojamas</li> <li>Prid\u0117kite smart pointers - polimorfizmui</li> <li>Praktikuokite su realiais projektais - \u012ftvirtinsite \u017einias</li> </ol> <p>Pagrindin\u0117 \u017einut\u0117: Modern C++ suteikia galingus \u012frankius objekt\u0173 masyv\u0173 valdymui. Naudokite STL konteinerius ir smart pointers - jie sprend\u017eia daugum\u0105 problem\u0173 automati\u0161kai ir saugiai.</p>"},{"location":"evolution/evoliucija-problemos/","title":"Konceptual\u016bs barjerai pereinant nuo C prie C++: Evoliucinio metodo sprendimai","text":""},{"location":"evolution/evoliucija-problemos/#ivadas","title":"\u012evadas","text":"<p>Per\u0117jimas nuo proced\u016brinio C programavimo prie objektinio C++ da\u017enai sukelia studentams rimt\u0173 sunkum\u0173. \u0160ie sunkumai atsiranda ne d\u0117l sintaks\u0117s sud\u0117tingumo, o d\u0117l fundamentali\u0173 m\u0105stymo paradigm\u0173 skirtum\u0173. Evoliucinis metodas sistemingai sprend\u017eia \u0161iuos barjerus, leisdamas studentams nat\u016braliai progresuoti.</p>"},{"location":"evolution/evoliucija-problemos/#1-pagrindinis-barjeras-duomenu-ir-funkciju-atskyrimas-suvienijimas","title":"1. Pagrindinis barjeras: Duomen\u0173 ir funkcij\u0173 atskyrimas \u2192 Suvienijimas","text":""},{"location":"evolution/evoliucija-problemos/#problema","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 m\u0105styti duomenimis ir funkcijomis kaip atskirais elementais:</p> <pre><code>// C m\u0105stymas: duomenys ir funkcijos atskirai\nchar stack[10];\nint top = 0;\n\nvoid push(char c) { /* ... */ }\nchar pop(void) { /* ... */ }\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas","title":"Evoliucinio metodo sprendimas","text":"<p>1-3 etapai: Palaipsnis art\u0117jimas <pre><code>// Etapas 1: Global\u016bs duomenys + funkcijos\nchar stack[10]; int top = 0;\nvoid push(char c);\n\n// Etapas 2: Modulinis dizainas (vis dar atskirai)\n// stack_2.h - funkcijos, stack_2.c - duomenys\n\n// Etapas 3: static pasl\u0117pimas (art\u0117jimas prie suvienijimo)\nstatic char stack[10]; static int top = 0;\n</code></pre></p> <p>4-5 etapai: Konceptualus \u0161uolis <pre><code>// Etapas 4: typedef struct (duomenys kartu)\ntypedef struct {\n    char stack[10];\n    int top;\n} stack;\n\n// Etapas 5: struct su metodais (suvienijimas!)\nstruct stack {\n    char stackas[10];\n    int top;\n    void push(char c);  // Metodas!\n    char pop();\n};\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#kodel-evoliucinis-metodas-veikia","title":"Kod\u0117l evoliucinis metodas veikia?","text":"<ul> <li>Nat\u016bralus progresavimas: Nuo \u017einomo (atskirai) prie ne\u017einomo (kartu)</li> <li>Motyvacija: Kiekvienas \u017eingsnis sprend\u017eia ankstesnio problemas</li> <li>Praktinis supratimas: Studentai mato, kod\u0117l reikia suvienijimo</li> </ul>"},{"location":"evolution/evoliucija-problemos/#2-atminties-valdymo-paradigmos-barjeras","title":"2. Atminties valdymo paradigmos barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_1","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 prie manual memory management, bet nesupranta objekt\u0173 lifecycle:</p> <pre><code>// C stilius: manual kontrol\u0117\nchar* data = malloc(100);\n// ... naudojimas\nfree(data);  // Reikia nepamirsti!\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_1","title":"Evoliucinio metodo sprendimas","text":"<p>6-7 etapai: RAII principas <pre><code>// Etapas 6: Konstruktorius (automatinis prad\u017eia)\nclass stack {\npublic:\n    stack() { top = 0; }  // Automatinis!\n};\n\n// Etapas 7: Konstruktorius + destruktorius (pilnas ciklas)\nclass stack {\npublic:\n    stack(int sz) { stackas = new char[sz]; }  // Gauna i\u0161teklius\n    ~stack() { delete[] stackas; }             // Atlaisvina i\u0161teklius\n};\n</code></pre></p> <p>8-9 etapai: Objekt\u0173 kopijavimo supratimas <pre><code>// Etapas 8: Rule of Three (deep copy)\nstack s1(10);\nstack s2 = s1;  // Dabar supranta, kad reikia kopijuoti duomenis!\n\n// Etapas 9: Rule of Five (move semantics)\nstack s3 = create_stack();  // Supranta, kad galima \"pavogti\"!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#pedagogine-verte","title":"Pedagogin\u0117 vert\u0117","text":"<ul> <li>Crash mokymasis: 7 etapas be Rule of Three crash'ina \u2192 motyvacija</li> <li>Vizualizacija: Shallow vs deep copy diagramos</li> <li>Performance supratimas: Move semantics 1000x grei\u010diau</li> </ul>"},{"location":"evolution/evoliucija-problemos/#3-prieigos-kontroles-encapsulation-barjeras","title":"3. Prieigos kontrol\u0117s (encapsulation) barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_2","title":"Problema","text":"<p>C programuotojai nesupranta, kod\u0117l reikia sl\u0117pti duomenis:</p> <pre><code>// C mentalitetas: \"Viskas turi b\u016bti prieinamas\"\ntypedef struct {\n    char data[10];  // Kod\u0117l negaliu tiesiogiai keisti?\n    int top;\n} stack;\n\nstack st;\nst.data[st.top++] = 'X';  // \"Tai mano duomenys!\"\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_2","title":"Evoliucinio metodo sprendimas","text":"<p>2-3 etapai: Problemos demonstracija <pre><code>// Etapas 2: Global\u016bs duomenys - problemos\nextern char stack[10];\nstack[top++] = '!';  // Pa\u017eeid\u017eia modulio logik\u0105!\n\n// Etapas 3: static apsauga\nstatic char stack[10];  // Linker klaidos moko!\n</code></pre></p> <p>5-6 etapai: C++ sprendimas <pre><code>// Etapas 5: struct metodai, bet duomenys prieinami\nstruct stack {\n    char stackas[10];  // Vis dar galima: st.stackas[0] = 'X'\n    void push(char c);\n};\n\n// Etapas 6: private/public - tikra apsauga!\nclass stack {\nprivate:\n    char stackas[10];  // Kompiliatorius neleid\u017eia!\npublic:\n    void push(char c);\n};\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#mokymosi-procesas","title":"Mokymosi procesas","text":"<ul> <li>Klaidos kaip mokytojai: Linker klaidos rodo apsaugos svarb\u0105</li> <li>Kompiliatoriaus pagalba: private klaidos motyvuoja public interface</li> <li>Praktinis supratimas: Mato, kaip apsauga padeda vengti klaid\u0173</li> </ul>"},{"location":"evolution/evoliucija-problemos/#4-objektu-koncepcijos-barjeras","title":"4. Objekt\u0173 koncepcijos barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_3","title":"Problema","text":"<p>C programuotojai m\u0105sto funkcijomis, ne objektais:</p> <pre><code>// C m\u0105stymas: \"K\u0105 daryti?\"\npush(data, 'X');\nchar c = pop(data);\nreset(data);\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_3","title":"Evoliucinio metodo sprendimas","text":"<p>4-6 etapai: Objektinio m\u0105stymo formavimas <pre><code>// Etapas 4: Objektai kaip duomen\u0173 strukt\u016bros\nstack st1, st2;  // Du objektai!\npush(&amp;st1, 'X');  // Vis dar funkcinis m\u0105stymas\n\n// Etapas 5-6: Objektai su elgesiu\nstack st1, st2;\nst1.push('X');    // Objektas daro veiksmus!\nst2.push('Y');    // Kiekvienas objektas nepriklausomas\n</code></pre></p> <p>7-10 etapai: Pilnavertis objektinis m\u0105stymas <pre><code>// Etapas 7: Objektai su lifecycle\nstack st(100);    // Objektas sukuriamas su parametrais\n// Automati\u0161kai sunaikinamas\n\n// Etapas 10: Template objektai\nStack&lt;string&gt; string_stack;  // Objektai gali b\u016bti bet kokio tipo\nStack&lt;int&gt; int_stack;\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#konceptualus-suolis","title":"Konceptualus \u0161uolis","text":"<ul> <li>Nuo \"k\u0105 daryti\" prie \"kas daro\": st.push() vs push(&amp;st)</li> <li>Objekt\u0173 nepriklausomumas: Kiekvienas objektas - atskiras pasaulis</li> <li>Lifecycle supratimas: Objektai gimsta, gyvena, mir\u0161ta</li> </ul>"},{"location":"evolution/evoliucija-problemos/#5-tipo-saugumo-barjeras","title":"5. Tipo saugumo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_4","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 prie void* ir manual casting:</p> <pre><code>// C stilius: \"A\u0161 \u017einau, k\u0105 darau\"\nvoid* data = malloc(100);\nchar* stack = (char*)data;  // Manual cast\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_4","title":"Evoliucinio metodo sprendimas","text":"<p>5-6 etapai: C++ tipo saugumas <pre><code>// Etapas 5: const vietoj #define\nconst int STACK_SIZE = 10;  // Tipo saugumas!\n\n// Etapas 6: Konstruktori\u0173 tipo tikrinimas\nstack st(10);     // Kompiliatorius tikrina tipus\nstack st2 = st;   // Tipo suderinamumas\n</code></pre></p> <p>10 etapas: Template tipo saugumas <pre><code>// Modern C++: Pilnas tipo saugumas\nStack&lt;int&gt; int_stack;\nStack&lt;string&gt; string_stack;\n\nint_stack.push(42);        // OK\nint_stack.push(\"hello\");   // Kompiliatoriaus klaida!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#pedagogine-verte_1","title":"Pedagogin\u0117 vert\u0117","text":"<ul> <li>Kompiliatoriaus pagalba: Klaidos compile time, ne runtime</li> <li>Template supratimas: Vienas kodas, daug tip\u0173</li> <li>Saugumo kult\u016bra: Kompiliatorius - draugas, ne prie\u0161as</li> </ul>"},{"location":"evolution/evoliucija-problemos/#6-performance-supratimo-barjeras","title":"6. Performance supratimo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_5","title":"Problema","text":"<p>C programuotojai mano, kad C++ l\u0117tesnis:</p> <pre><code>// C mentalitetas: \"C++ turi overhead\"\nchar stack[10];  // \"Grei\u010diausias b\u016bdas\"\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_5","title":"Evoliucinio metodo sprendimas","text":"<p>8-9 etapai: Performance demonstracija <pre><code>// Etapas 8: Rule of Three - rodo kopijavimo kain\u0105\nstack s1(1000);\nstack s2 = s1;  // Kopijuoja 1000 element\u0173!\n\n// Etapas 9: Move semantics - rodo optimizacijas\nstack s3 = create_stack();  // Tik pointer swap!\n// 1000x grei\u010diau nei kopijavimas\n</code></pre></p> <p>10 etapas: Zero-overhead abstractions <pre><code>// Modern C++: Grei\u010diau nei C!\nStack&lt;int&gt; st;\nst.push(42);  // Inline funkcija - jokio overhead!\n\n// Kompiliatorius optimizuoja geriau nei manual C kodas\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#supratimo-formavimas","title":"Supratimo formavimas","text":"<ul> <li>Matavimas: Real\u016bs benchmark'ai rodo skirtum\u0105</li> <li>Profiling: Valgrind, performance tools</li> <li>Optimizacij\u0173 supratimas: Kompiliatorius protingesnis nei \u017emogus</li> </ul>"},{"location":"evolution/evoliucija-problemos/#7-sintakses-sudetingumo-barjeras","title":"7. Sintaks\u0117s sud\u0117tingumo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_6","title":"Problema","text":"<p>C++ sintaks\u0117 atrodo bauginanti:</p> <pre><code>// Bauginanti sintaks\u0117\ntemplate&lt;typename T&gt;\nclass Stack {\n    Stack(const Stack&amp; other);\n    Stack&amp; operator=(Stack&amp;&amp; other) noexcept;\n};\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_6","title":"Evoliucinio metodo sprendimas","text":"<p>Palaipsnis sintaks\u0117s \u012fvedimas: <pre><code>// Etapas 5: Paprasta sintaks\u0117\nstruct stack {\n    void push(char c);  // Pa\u017e\u012fstama!\n};\n\n// Etapas 6: Nauja sintaks\u0117 po truput\u012f\nclass stack {\nprivate:  // Naujas \u017eodis\n    char data[10];\npublic:   // Naujas \u017eodis\n    stack();  // Konstruktorius\n};\n\n// Etapas 8-9: Sud\u0117tingesn\u0117 sintaks\u0117 su motyvacija\nstack(const stack&amp; other);  // Dabar supranta, kod\u0117l reikia!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#mokymosi-strategija","title":"Mokymosi strategija","text":"<ul> <li>Vienas naujas elementas per kart\u0105: Ne viskas i\u0161 karto</li> <li>Motyvacija pirma: Kod\u0117l reikia, tada kaip</li> <li>Praktinis naudojimas: Kiekviena sintaks\u0117 turi tiksl\u0105</li> </ul>"},{"location":"evolution/evoliucija-problemos/#lyginamoji-analize-metodu","title":"Lyginamoji analiz\u0117 metod\u0173","text":"Barjeras Tradicinis OOP-first Evoliucinis metodas Rezultatas Duomen\u0173 suvienijimas \"Objektas - tai...\" (abstraktus) Global\u016bs \u2192 moduliai \u2192 struct \u2192 class \u2705 Nat\u016bralus supratimas Atminties valdymas \"Naudokite smart_ptr\" (magi\u0161kas) malloc \u2192 new/delete \u2192 RAII \u2192 Rule of 3/5 \u2705 Gil\u016bs pagrindai Encapsulation \"private - gerai, public - blogai\" Global\u016bs \u2192 static \u2192 private (su klaidomis) \u2705 Motyvuotas supratimas Objekt\u0173 koncepcija \"Objektas modeliuoja realyb\u0119\" Funkcijos \u2192 struct \u2192 metodai \u2192 objektai \u2705 Praktinis supratimas Tipo saugumas \"Templates - generinis programavimas\" void* \u2192 const \u2192 class \u2192 template \u2705 Palaipsnis augimas Performance \"C++ optimizuotas\" (tik\u0117jimas) Manual \u2192 copy \u2192 move \u2192 zero-overhead \u2705 \u012erodomas supratimas"},{"location":"evolution/evoliucija-problemos/#studentu-atsiliepimu-analize","title":"Student\u0173 atsiliepim\u0173 analiz\u0117","text":""},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-studentai","title":"Evoliucinio metodo studentai:","text":"<p>\"Dabar suprantu, kod\u0117l reikia private - ma\u010diau, kaip global\u016bs kintamieji suk\u0117l\u0117 problemas\"</p> <p>\"Rule of Three n\u0117ra bauginantis - matau, kad tai sprend\u017eia crash'\u0173 problem\u0105\"</p> <p>\"Move semantics - tai ne magija, o paprastas pointer swap\"</p>"},{"location":"evolution/evoliucija-problemos/#tradicinio-metodo-studentai","title":"Tradicinio metodo studentai:","text":"<p>\"Ne\u017einau, kod\u0117l reikia vis\u0173 \u0161i\u0173 class, private, public...\"</p> <p>\"C++ atrodo sud\u0117tingas ir l\u0117tas\"</p> <p>\"Nesupranta, kada naudoti k\u0105\"</p>"},{"location":"evolution/evoliucija-problemos/#metodines-rekomendacijos","title":"Metodin\u0117s rekomendacijos","text":""},{"location":"evolution/evoliucija-problemos/#destytojams","title":"D\u0117stytojams:","text":"<ol> <li>Neskub\u0117kite: Leiskite studentams patirti problemas prie\u0161 duodant sprendimus</li> <li>Naudokite klaidas: Crash'ai ir linker klaidos - puik\u016bs mokytojai</li> <li>Vizualizuokite: Memory layout, shallow vs deep copy diagramos</li> <li>Matuokite: Performance benchmark'ai \u012ftikina geriau nei teorija</li> <li>Praktikuokite: Kiekviena koncepcija turi praktin\u012f projekt\u0105</li> </ol>"},{"location":"evolution/evoliucija-problemos/#studentams","title":"Studentams:","text":"<ol> <li>Nepamir\u0161kite C \u017eini\u0173: Jos - pagrindas C++ supratimui</li> <li>Eksperimentuokite: Bandykite sulau\u017eyti kod\u0105 ir suprasti kod\u0117l</li> <li>Testuokite: Valgrind, unit testai - j\u016bs\u0173 draugai</li> <li>Matuokite: Performance profiling atskleid\u017eia ties\u0105</li> <li>Kantryb\u0117: Objektinis m\u0105stymas formuojasi laipsni\u0161kai</li> </ol>"},{"location":"evolution/evoliucija-problemos/#isvados","title":"I\u0161vados","text":"<p>Evoliucinis metodas s\u0117kmingai sprend\u017eia pagrindinius konceptualius barjerus pereinant nuo C prie C++:</p>"},{"location":"evolution/evoliucija-problemos/#pagrindiniai-privalumai","title":"Pagrindiniai privalumai:","text":"<ul> <li>Nat\u016bralus progresavimas: Nuo \u017einomo prie ne\u017einomo</li> <li>Motyvuotas mokymasis: Kiekvienas \u017eingsnis sprend\u017eia reali\u0105 problem\u0105  </li> <li>Gil\u016bs pagrindai: Supranta ne tik \"kaip\", bet ir \"kod\u0117l\"</li> <li>Praktinis fokusas: Teorija i\u0161plaukia i\u0161 praktikos</li> </ul>"},{"location":"evolution/evoliucija-problemos/#ilgalaikis-poveikis","title":"Ilgalaikis poveikis:","text":"<ul> <li>Studentai geriau supranta C++ filosofij\u0105</li> <li>Ma\u017eiau baim\u0117s prie\u0161 sud\u0117tingas konstrukcijas</li> <li>Geresni debugging \u012fg\u016bd\u017eiai</li> <li>Stipresni performance optimization pagrindai</li> </ul> <p>Svarbiausias principas: Leiskite studentams patiems atrasti, kod\u0117l reikia objektinio programavimo, vietoj to, kad tiesiog pasakytum\u0117te, jog taip yra geriau.</p>"},{"location":"evolution/stack-evoliucija-test/","title":"Nuo C link C++: Metodinis vadovas su Stack ADT evoliucija","text":""},{"location":"evolution/stack-evoliucija-test/#ivadas-evoliucinis-mokymo-metodas","title":"\u012evadas: Evoliucinis mokymo metodas","text":"<p>\u0160is metodinis vadovas skirtas studentams, pereinantiems nuo C programavimo kalbos prie C++. Naudojamas evoliucinis metodas - palaipsnis kodo tobulinimas, rodantis, kaip proced\u016brinis programavimas nat\u016braliai transformuojasi \u012f objektin\u012f programavim\u0105.</p> <p>Metodikos esm\u0117: Kiekvienas \u017eingsnis sprend\u017eia ankstesn\u0117s versijos problemas ir pristato nauj\u0105 C++ koncepcij\u0105, i\u0161laikant funkcionalum\u0105, bet gerinant kodo kokyb\u0119.</p>"},{"location":"evolution/stack-evoliucija-test/#kodel-stack-stekas-kaip-pavyzdys","title":"Kod\u0117l Stack (stekas) kaip pavyzdys?","text":"<p>Stack duomen\u0173 strukt\u016bra idealiai tinka C++ mokymui, nes:</p> <ul> <li>Paprasta koncepcija: LIFO (Last In, First Out) principas</li> <li>Ai\u0161k\u016bs metodai: push(), pop(), top()</li> <li>Evoliucijos galimyb\u0117s: nuo globali\u0173 kintam\u0173j\u0173 iki \u0161iuolaikini\u0173 C++ klasi\u0173</li> <li>Praktinis pritaikymas: naudojama daugelyje algoritm\u0173</li> </ul>"},{"location":"evolution/stack-evoliucija-test/#1-etapas-stack-kaip-programa-c-stilius","title":"1 etapas: Stack kaip \"programa\" (C stilius)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija","title":"Koncepcija","text":"<p>Pirmasis etapas pristato klasikin\u012f C programavimo stili\u0173 su globaliais kintamaisiais ir funkcijomis. \u0160is metodas, nors paprastas ir intuityvus pradedantiesiems, atskleid\u017eia fundamentalias problemas, kurias spr\u0119s v\u0117lesni etapai. Global\u016bs kintamieji ir funkcij\u0173 atskyrimas nuo duomen\u0173 formuoja pagrind\u0105 supratimui, kod\u0117l reikalingas objektinis programavimas.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_1.c\n#include &lt;stdio.h&gt;\n#define STACK_SIZE 10\n\nchar stack[STACK_SIZE];  // Globalus masyvas\nint  top = 0;           // Globalus indeksas\n\nvoid push(char c);\nchar pop(void);\n\nint main(void) {\n    int c;\n\n    // \u012evedimas ir sud\u0117jimas \u012f stek\u0105\n    while ('\\n' != (c=getchar())) push(c);\n\n    // I\u0161\u0117mimas ir spausdinimas (atvirk\u0161\u010diai)\n    while ('\\n' != (c=pop())) putchar(c);\n\n    return 0;\n}\n\nvoid push(char c) {\n    if (top &lt; STACK_SIZE) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (top &gt; 0) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre> <p>Veikimo pavyzdys: - \u012evedimas: <code>12345</code> - I\u0161vedimas: <code>54321</code></p>"},{"location":"evolution/stack-evoliucija-test/#problemos-analize","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kinimas Pasekm\u0117s Global\u016bs kintamieji stack[] ir top prieinami visur Sunku kontroliuoti prieig\u0105 Vienas stekas Negalima sukurti keli\u0173 stek\u016f Ribota funkcionalumas N\u0117ra inkapsuliavimo Duomenys ir funkcijos atskirti Sunku palaikyti kod\u0105 N\u0117ra klaid\u0173 tikrinimo Primityvus klaid\u0173 valdymas Nesaugus kodas"},{"location":"evolution/stack-evoliucija-test/#2-etapas-stack-kaip-modulis-su-nepaslepta-realizacija","title":"2 etapas: Stack kaip \"modulis su nepasl\u0117pta realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_1","title":"Koncepcija","text":"<p>Antrasis etapas pristato modulinio programavimo prad\u017ei\u0105 - kodo skaidym\u0105 \u012f header ir implementation failus. \u0160is \u017eingsnis formuoja supratim\u0105 apie kodo organizavim\u0105 ir funkcij\u0173 deklaravim\u0105 bei apibr\u0117\u017eim\u0105. Ta\u010diau duomen\u0173 globalumas i\u0161lieka, atskleid\u017eiant modulinio dizaino ribas be tikro inkapsuliavimo.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_1","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_2.h\n#define STACK_SIZE 10\n\nvoid reset(void);\nvoid push(char);\nchar pop(void);\n\n// stack_2.c\n#include &lt;stdio.h&gt;\n#include \"stack_2.h\"\n\nchar stack[STACK_SIZE];  // Vis dar globalus\nint  top = 0;\n\nvoid reset(void) {\n    top = 0;\n}\n\nvoid push(char c) {\n    if (top &lt; STACK_SIZE) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (top &gt; 0) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#kompiliatoriaus-perspejimai","title":"\u26a0\ufe0f Kompiliatoriaus persp\u0117jimai","text":"<pre><code>Linker warning:\nPublic symbol '_stack' defined in both module DRIVER_2.OBJ and STACK_2.OBJ\nPublic symbol '_top' defined in both module DRIVER_2.OBJ and STACK_2.OBJ\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#problemos-analize_1","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Pager\u0117jimas Likusios problemos \u2705 Modulinis dizainas \u274c Duomenys vis dar global\u016bs \u2705 Header failas \u274c Galima tiesiogiai keisti duomenis \u2705 reset() funkcija \u274c Simboli\u0173 dubliavimas"},{"location":"evolution/stack-evoliucija-test/#3-etapas-stack-kaip-modulis-su-paslepta-realizacija","title":"3 etapas: Stack kaip \"modulis su pasl\u0117pta realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_2","title":"Koncepcija","text":"<p>Tre\u010diasis etapas pristato informacijos sl\u0117pimo princip\u0105 naudojant <code>static</code> rakta\u017eod\u012f. \u0160is konceptualus \u0161uolis formuoja supratim\u0105 apie duomen\u0173 apsaug\u0105 ir modulio vidin\u0117s logikos pasl\u0117pim\u0105. Linker klaidos tampa mokymo \u012frankiu, demonstruojan\u010diu, kaip kompiliatorius apsaugo nuo neleistinos prieigos.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_2","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_3.h\n#define STACK_SIZE 10\n\nvoid reset(void);\nvoid push(char);\nchar pop(void);\n\n// stack_3.c\n#include &lt;stdio.h&gt;\n#include \"stack_3.h\"\n\nstatic char stack[STACK_SIZE];  // \ud83d\udd12 Pasl\u0117pta!\nstatic int  top = 0;\nstatic int is_empty(void) { return (0 == top); }\nstatic int is_full(void) { return (STACK_SIZE == top); }\n\nvoid reset(void) {\n    top = 0;\n}\n\nvoid push(char c) {\n    if (!is_full()) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (!is_empty()) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#linker-klaidos","title":"\u274c Linker klaidos","text":"<pre><code>Link error: Unresolved external '_is_full' referenced from DRIVER_3.OBJ\nLink error: Unresolved external '_stack' referenced from DRIVER_3.OBJ\nLink error: Unresolved external '_top' referenced from DRIVER_3.OBJ\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize","title":"\ud83d\udd0d Analiz\u0117","text":"Pager\u0117jimas Mokymosi vert\u0117 \u2705 static - duomen\u0173 pasl\u0117pimas Informacijos sl\u0117pimo principas \u2705 Pagalbin\u0117s funkcijos pasl\u0117ptos Modulio vidin\u0117 logika \u2705 Linker klaidos rodo apsaug\u0105 Kompiliatoriaus apsauga"},{"location":"evolution/stack-evoliucija-test/#4-etapas-stack-kaip-tipas-modulyje","title":"4 etapas: Stack kaip \"tipas (modulyje)\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_3","title":"Koncepcija","text":"<p>Ketvirtasis etapas pristato duomen\u0173 strukt\u016br\u0173 koncepcij\u0105 per <code>typedef struct</code>. \u0160is \u017eingsnis formuoja supratim\u0105 apie duomen\u0173 ir funkcij\u0173 s\u0105ry\u0161\u012f, leid\u017eia kurti kelis objektus ir pristato rodykli\u0173 perdavimo b\u016btinyb\u0119. Tai tiltas tarp proced\u016brinio ir objektinio programavimo.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_3","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_4.h\n#define STACK_SIZE 10\n\ntypedef struct {\n    char stack[STACK_SIZE];\n    int  top;\n} stack;\n\nvoid reset(stack *);\nvoid push(stack *, char);\nchar pop(stack *);\n\n// stack_4.c\n#include &lt;stdio.h&gt;\n#include \"stack_4.h\"\n\nstatic int is_empty(stack *id) {\n    return (0 == id-&gt;top);\n}\n\nstatic int is_full(stack *id) {\n    return (STACK_SIZE == id-&gt;top);\n}\n\nvoid reset(stack *id) {\n    id-&gt;top = 0;\n}\n\nvoid push(stack *id, char c) {\n    if (!is_full(id)) \n        id-&gt;stack[id-&gt;top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(stack *id) {\n    if (!is_empty(id)) \n        return id-&gt;stack[--id-&gt;top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_1","title":"\ud83d\udd0d Analiz\u0117","text":"Pager\u0117jimas Likusios problemos \u2705 Keli\u0173 stek\u016f galimyb\u0117 \u274c Duomenys vis dar prieinami \u2705 typedef struct \u274c Reikia perduoti rodykles \u2705 Ai\u0161kesn\u0117 sintaks\u0117 \u274c Galimi segmentation fault"},{"location":"evolution/stack-evoliucija-test/#5-etapas-stack-kaip-struktura-klase-c-pradzia","title":"5 etapas: Stack kaip \"strukt\u016bra-klas\u0117\" (C++ prad\u017eia)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_4","title":"Koncepcija","text":"<p>Penktasis etapas \u017eymi per\u0117jim\u0105 \u012f C++ - pristato <code>struct</code> su metodais ir <code>::</code> operatori\u0173. \u0160is konceptualus \u0161uolis formuoja supratim\u0105 apie duomen\u0173 ir funkcij\u0173 suvienijim\u0105 vienoje strukt\u016broje. Kompiliatoriaus klaidos atskleid\u017eia prieigos kontrol\u0117s poreik\u012f.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_4","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_5.h\nconst int STACK_SIZE = 10;\n\nstruct stack {\n    char stackas[STACK_SIZE];\n    int  top;\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n};\n\n// stack_5.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_5.h\"\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (STACK_SIZE == top); \n}\n\nvoid stack::reset() { \n    top = 0; \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_2","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Problema struct su metodais Duomenys ir funkcijos kartu :: operatorius Ai\u0161ki priklausomyb\u0117 klasei const vietoj #define Tipo saugumas Klaida su reset() Rodo, kad reikia public sekcijos!"},{"location":"evolution/stack-evoliucija-test/#6-etapas-stack-kaip-klase-informacijos-slepimas","title":"6 etapas: Stack kaip \"klas\u0117\" (Informacijos sl\u0117pimas)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_5","title":"Koncepcija","text":"<p>\u0160e\u0161tasis etapas pristato tikr\u0105 objektin\u012f programavim\u0105 - <code>class</code> su <code>private</code> ir <code>public</code> sekcijomis bei konstruktori\u0173. \u0160is konceptualus prover\u017eis formuoja supratim\u0105 apie tikr\u0105 inkapsuliavim\u0105, automatin\u012f objekt\u0173 inicializavim\u0105 ir kompiliatoriaus apsaug\u0105 nuo neleistinos prieigos.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_5","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_6.h\nconst int STACK_SIZE = 10;\n\nclass stack {\nprivate:  // \ud83d\udd12 Pasl\u0117pta!\n    char stackas[STACK_SIZE];\n    int  top;\n    int  is_empty();\n    int  is_full();\n\npublic:   // \ud83c\udf10 Vie\u0161as interfeisas\n    stack();           // \ud83c\udf89 Konstruktorius!\n    void push(char);\n    char pop();\n};\n\n// stack_6.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_6.h\"\n\nstack::stack() { \n    top = 0; \n}\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (STACK_SIZE == top); \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_3","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Nauda private: sekcija Tikras duomen\u0173 pasl\u0117pimas public: sekcija Ai\u0161kus interfeisas Konstruktorius Automatinis inicializavimas Kompiliatoriaus apsauga Neleid\u017eia pa\u017eeisti inkapsuliavimo"},{"location":"evolution/stack-evoliucija-test/#7-etapas-stack-kaip-klase-su-dinamiska-realizacija","title":"7 etapas: Stack kaip \"klas\u0117 su dinami\u0161ka realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_6","title":"Koncepcija","text":"<p>Septintasis etapas pristato dinaminio atminties valdymo koncepcij\u0105 su <code>new</code>/<code>delete</code> operatoriais ir destruktoriumi. \u0160is \u017eingsnis formuoja supratim\u0105 apie RAII (Resource Acquisition Is Initialization) princip\u0105 ir automatin\u012f i\u0161tekli\u0173 valdym\u0105. Parametrinis konstruktorius leid\u017eia lanks\u010diai inicializuoti objektus.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_6","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_7.h\nclass stack {\nprivate:\n    char *stackas;  // \ud83c\udfaf Dinaminis masyvas!\n    int  top;\n    int  size;\n\npublic:\n    stack(int);      // \ud83c\udf89 Parametrinis konstruktorius!\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n    int  get_size();\n    ~stack();        // \ud83c\udf89 Destruktorius!\n};\n\n// stack_7.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_7.h\"\n\nstack::stack(int sz) { \n    stackas = new char[size = sz]; \n    reset(); \n}\n\nvoid stack::reset() {\n    top = 0; \n}\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (size == top); \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n\nint stack::get_size() { \n    return size; \n}\n\nstack::~stack() { \n    delete [] stackas; \n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_4","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Nauda Parametrinis konstruktorius Lankstus inicializavimas new/delete Dinaminis atminties valdymas Destruktorius Automatinis i\u0161valymas cout vietoj printf C++ I/O srautai"},{"location":"evolution/stack-evoliucija-test/#8-etapas-rule-of-three-kopijavimo-semantika","title":"8 etapas: Rule of Three - Kopijavimo semantika","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_7","title":"Koncepcija","text":"<p>A\u0161tuntasis etapas pristato vien\u0105 svarbiausi\u0173 C++ koncepcij\u0173 - Rule of Three. \u0160is principas formuoja supratim\u0105 apie objekt\u0173 kopijavimo problemas ir deep copy b\u016btinyb\u0119. Koncepcija atskleid\u017eia, kod\u0117l dinaminio atminties valdymo atveju reikalingi special\u016bs kopijos konstruktorius ir priskyrimo operatorius.</p> <p>Rule of Three taisykl\u0117: Jei klasei reikia vieno i\u0161 trij\u0173 - destruktoriaus, kopijos konstruktoriaus ar priskyrimo operatoriaus, tai grei\u010diausiai reikia vis\u0173 trij\u0173.</p>"},{"location":"evolution/stack-evoliucija-test/#problema-su-7-etapu","title":"Problema su 7 etapu","text":"<pre><code>int main() {\n    stack s1(10);\n    s1.push('A');\n    s1.push('B');\n\n    stack s2 = s1;  // \u26a0\ufe0f Kopijos konstruktorius!\n    // arba\n    stack s3(5);\n    s3 = s1;        // \u26a0\ufe0f Priskyrimo operatorius!\n\n    return 0;       // \ud83d\udca5 CRASH! Double delete!\n}\n</code></pre> <p>Problema: Kompiliatorius automati\u0161kai sukuria \"shallow copy\" - kopijuoja tik pointer reik\u0161m\u0119, ne duomenis!</p>"},{"location":"evolution/stack-evoliucija-test/#rule-of-three-sprendimas","title":"Rule of Three sprendimas","text":"<pre><code>// stack_8.h\nclass stack {\nprivate:\n    char *stackas;\n    int  top;\n    int  size;\n\npublic:\n    stack(int);                        // Konstruktorius\n    stack(const stack&amp; other);         // \ud83c\udf89 Kopijos konstruktorius!\n    stack&amp; operator=(const stack&amp; other); // \ud83c\udf89 Priskyrimo operatorius!\n    ~stack();                          // Destruktorius\n\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n    int  get_size();\n};\n\n// Kopijos konstruktorius (deep copy)\nstack::stack(const stack&amp; other) {\n    size = other.size;\n    top = other.top;\n    stackas = new char[size];  // \ud83c\udfaf Naujas masyvas!\n\n    // Kopijuojame duomenis\n    for(int i = 0; i &lt;= top; i++) {\n        stackas[i] = other.stackas[i];\n    }\n}\n\n// Priskyrimo operatorius\nstack&amp; stack::operator=(const stack&amp; other) {\n    if(this == &amp;other) {       // \ud83d\udee1\ufe0f Apsauga nuo self-assignment\n        return *this;\n    }\n\n    delete[] stackas;          // \ud83d\uddd1\ufe0f I\u0161valome sen\u0105 atmint\u012f\n\n    size = other.size;\n    top = other.top;\n    stackas = new char[size];  // \ud83c\udfaf Naujas masyvas!\n\n    // Kopijuojame duomenis\n    for(int i = 0; i &lt;= top; i++) {\n        stackas[i] = other.stackas[i];\n    }\n\n    return *this;              // \ud83d\udd04 Gr\u0105\u017einame nuorod\u0105\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#9-etapas-rule-of-five-move-semantika","title":"9 etapas: Rule of Five - Move semantika","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_8","title":"Koncepcija","text":"<p>Devintasis etapas pristato Rule of Five ir move semantikos koncepcij\u0105 i\u0161 C++11. \u0160is \u017eingsnis formuoja supratim\u0105 apie efektyv\u0173 objekt\u0173 perk\u0117lim\u0105 vietoj kopijavimo, ypa\u010d su temporary objektais. Move semantika drasti\u0161kai pagerina performance, nes \"pavogia\" duomenis vietoj j\u0173 kopijavimo.</p> <p>Rule of Five: Rule of Three + move konstruktorius + move assignment operatorius.</p>"},{"location":"evolution/stack-evoliucija-test/#problema-su-rule-of-three","title":"Problema su Rule of Three","text":"<pre><code>stack create_temp_stack() {\n    stack temp(1000);\n    temp.push('X');\n    return temp;  // \ud83d\udcb8 Brangus kopijavimas!\n}\n\nint main() {\n    stack s1 = create_temp_stack();  // Copy constructor\n    stack s2(500);\n    s2 = create_temp_stack();        // Assignment operator\n\n    // Kiekvienas i\u0161kvietimas kopijuoja 1000 char'\u0173 masyv\u0105!\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#move-semantics-sprendimas","title":"Move semantics sprendimas","text":"<pre><code>// Rule of Five papildymai (C++11)\nstack(stack&amp;&amp; other) noexcept;     // \ud83c\udf89 Move konstruktorius!\nstack&amp; operator=(stack&amp;&amp; other) noexcept; // \ud83c\udf89 Move assignment!\n\n// Move konstruktorius - \"pavogti\" duomenis\nstack::stack(stack&amp;&amp; other) noexcept \n    : stackas(other.stackas),    // \ud83c\udfc3\u200d\u2642\ufe0f Paimame pointer\n      top(other.top),\n      size(other.size) \n{\n    // Palikti other tu\u0161\u010di\u0105 b\u016bsen\u0119\n    other.stackas = nullptr;\n    other.top = 0;\n    other.size = 0;\n}\n\n// Move assignment operator\nstack&amp; stack::operator=(stack&amp;&amp; other) noexcept {\n    if(this == &amp;other) {         // Self-assignment check\n        return *this;\n    }\n\n    // I\u0161valome savo duomenis\n    delete[] stackas;\n\n    // \"Pavogti\" other duomenis\n    stackas = other.stackas;\n    top = other.top;\n    size = other.size;\n\n    // Palikti other tu\u0161\u010di\u0105 b\u016bsen\u0119\n    other.stackas = nullptr;\n    other.top = 0;\n    other.size = 0;\n\n    return *this;\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#10-etapas-modern-c-stack","title":"10 etapas: Modern C++ Stack","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_9","title":"Koncepcija","text":"<p>De\u0161imtasis etapas pristato \u0161iuolaikin\u012f C++ stili\u0173 su templates, STL konteineriais ir C++11+ funkcijomis. \u0160is finalinis \u017eingsnis demonstruoja, kaip evoliucijos metu \u012fgytos \u017einios leid\u017eia suprasti ir efektyviai naudoti \u0161iuolaikines C++ galimybes. Template sistema leid\u017eia kurti tipo-saugius ir lank\u0161\u010dius sprendimus.</p>"},{"location":"evolution/stack-evoliucija-test/#modern-c-implementacija","title":"Modern C++ implementacija","text":"<pre><code>// modern_stack.hpp\n#pragma once\n#include &lt;vector&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nclass Stack {\nprivate:\n    std::vector&lt;T&gt; data;\n\npublic:\n    // Konstruktoriai\n    Stack() = default;\n    explicit Stack(size_t initial_capacity) {\n        data.reserve(initial_capacity);\n    }\n\n    // Rule of Five (C++11) - kompiliatorius automati\u0161kai\n    Stack(const Stack&amp;) = default;\n    Stack&amp; operator=(const Stack&amp;) = default;\n    Stack(Stack&amp;&amp;) = default;\n    Stack&amp; operator=(Stack&amp;&amp;) = default;\n    ~Stack() = default;\n\n    // Pagrindin\u0117s operacijos\n    void push(const T&amp; item) {\n        data.push_back(item);\n    }\n\n    void push(T&amp;&amp; item) {  // Move semantics\n        data.push_back(std::move(item));\n    }\n\n    template&lt;typename... Args&gt;\n    void emplace(Args&amp;&amp;... args) {  // Perfect forwarding\n        data.emplace_back(std::forward&lt;Args&gt;(args)...);\n    }\n\n    T pop() {\n        if (empty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        T result = std::move(data.back());\n        data.pop_back();\n        return result;\n    }\n\n    const T&amp; top() const {\n        if (empty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        return data.back();\n    }\n\n    // Utility funkcijos\n    [[nodiscard]] bool empty() const noexcept {\n        return data.empty();\n    }\n\n    [[nodiscard]] size_t size() const noexcept {\n        return data.size();\n    }\n\n    void clear() noexcept {\n        data.clear();\n    }\n\n    // Iterator support\n    auto begin() { return data.begin(); }\n    auto end() { return data.end(); }\n    auto begin() const { return data.cbegin(); }\n    auto end() const { return data.cend(); }\n};\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#modern-c-naujoves","title":"\ud83d\udd0d Modern C++ naujov\u0117s","text":"Funkcija C++ versija Nauda template C++98 Tipo saugumas ir lankstumas std::vector C++98 Automatinis atminties valdymas = default C++11 Ai\u0161kus intent noexcept C++11 Optimizacijos galimyb\u0117s [[nodiscard]] C++17 Persp\u0117jimai apie nepanaudotas reik\u0161mes auto C++11/14 Tipo i\u0161vedimas Range-based for C++11 Paprastesnis iteravimas Perfect forwarding C++11 Efektyvus argument\u0173 perdavimas"},{"location":"evolution/stack-evoliucija-test/#isvados","title":"I\u0161vados","text":""},{"location":"evolution/stack-evoliucija-test/#evoliucinio-metodo-privalumai","title":"Evoliucinio metodo privalumai","text":"<ol> <li>Nat\u016bralus progresavimas: Nuo paprast\u0173 prie sud\u0117ting\u0173 koncepcij\u0173</li> <li>Motyvacija: Kiekvienas \u017eingsnis sprend\u017eia reali\u0105 problem\u0105</li> <li>Praktinis mokymasis: Ta pati u\u017eduotis, skirtingi sprendimai</li> <li>Klaid\u0173 mokymasis: Klaidos tampa mokymo \u012frankiu</li> </ol>"},{"location":"evolution/stack-evoliucija-test/#pagrindines-c-koncepcijos","title":"Pagrindin\u0117s C++ koncepcijos","text":"<ul> <li>Inkapsuliavimas: private/public</li> <li>Konstruktoriai/destruktoriai: Automatinis valdymas</li> <li>Rule of Three/Five: Objekt\u0173 kopijavimo ir perk\u0117limo valdymas</li> <li>Templates: Tipo saugumas ir lankstumas</li> <li>STL: Standartin\u0117s bibliotekos</li> </ul>"},{"location":"evolution/stack-evoliucija-test/#tolesnio-mokymosi-kryptys","title":"Tolesnio mokymosi kryptys","text":"<ul> <li>Paveld\u0117jimas: class Derived : public Base</li> <li>Polimorfizmas: Virtual funkcijos</li> <li>Templates: Generinis programavimas</li> <li>STL: Konteineriai ir algoritmai</li> <li>Modern C++: Smart pointers, lambdas, ranges</li> </ul> <p>Svarbu: \u0160is vadovas - tik prad\u017eia. C++ - plati ir gili kalba, reikalaujanti nuolatinio mokymosi ir praktikos. </p>"},{"location":"evolution/stack-evolution-1/","title":"ADT Stekas Evoliucija: Nuo C iki Modernaus C++","text":""},{"location":"evolution/stack-evolution-1/#turinys","title":"Turinys","text":"<ol> <li>\u012evadas ir Evoliucijos Ap\u017evalga</li> <li>1 Etapas: Monolitin\u0117 Programa</li> <li>2 Etapas: Fail\u0173 Dekompozicija</li> <li>3 Etapas: Moduli\u0173 Sistema</li> <li>4 Etapas: Informacijos Sl\u0117pimas</li> <li>5 Etapas: Vartotojo Apibr\u0117\u017eiamas Tipas</li> <li>6 Etapas: Tipas Modulyje</li> <li>7 Etapas: Pilna Inkapsuliacija</li> <li>Tipin\u0117s Klaidos ir J\u0173 Sprendimas</li> <li>Atak\u0173 Demonstracijos</li> <li>Praktiniai Patarimai</li> <li>Santrauka ir I\u0161vados</li> </ol>"},{"location":"evolution/stack-evolution-1/#ivadas-ir-evoliucijos-apzvalga","title":"\u012evadas ir Evoliucijos Ap\u017evalga","text":""},{"location":"evolution/stack-evolution-1/#kas-yra-adt-abstract-data-type","title":"Kas yra ADT (Abstract Data Type)?","text":"<p>Abstract Data Type - tai duomen\u0173 tipas, apibr\u0117\u017eiamas per jo elges\u012f (operacijas), o ne per vidin\u0119 strukt\u016br\u0105. ADT slepia implementacijos detales ir atskleid\u017eia tik s\u0105saj\u0105 (interface).</p>"},{"location":"evolution/stack-evolution-1/#kodel-svarbu-suprasti-evoliucija","title":"Kod\u0117l Svarbu Suprasti Evoliucij\u0105?","text":"<ul> <li>Istorinis kontekstas - kaip vyst\u0117si programavimo paradigmos</li> <li>Tipin\u0117s klaidos - koki\u0173 klaid\u0173 i\u0161vengti</li> <li>Dizaino principai - kod\u0117l tam tikri sprendimai yra geresni</li> <li>Praktiniai \u012fg\u016bd\u017eiai - kaip teisingai strukt\u016brizuoti kod\u0105</li> </ul>"},{"location":"evolution/stack-evolution-1/#evoliucijos-kelias","title":"Evoliucijos Kelias","text":"<p>apie dvi dalis</p>"},{"location":"evolution/stack-evolution-1/#i-dalis-nuo-naivaus-c-iki-brandaus-c","title":"I dalis: Nuo naivaus C iki brandaus C","text":"<p>\u0160is konspektas atskleid\u017eia pirmuosius C \"epochos\" 7 evoliucijos etapus, kurie parodo, kaip paprastas stekas transformuojasi \u012f pilnai inkapsuliuot\u0105 ADT:</p> <ul> <li>01 etapas: Monolitin\u0117 Programa</li> <li>02 etapas: Fail\u0173 Dekompozicija</li> <li>03 etapas: Moduli\u0173 Sistema</li> <li>04 etapas: Informacijos Sl\u0117pimas</li> <li>05 etapas: Vartotojo Apibr\u0117\u017eiamas Tipas</li> <li>06 etapas: Tipas Modulyje</li> <li>07 etapas: Pilna Inkapsuliacija</li> </ul>"},{"location":"evolution/stack-evolution-1/#1-etapas-monolitine-programa","title":"1 Etapas: Monolitin\u0117 Programa","text":""},{"location":"evolution/stack-evolution-1/#charakteristikos","title":"Charakteristikos","text":"<ul> <li>Viskas vienoje vietoje - duomenys, funkcijos ir main() funkcija</li> <li>Global\u016bs kintamieji - <code>stack[]</code> ir <code>top</code></li> <li>Tiesioginis prieigos - joki\u0173 abstrakcij\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#kodas-01_n_usestackc","title":"Kodas: <code>01_n_usestack.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nchar stack[SIZE];  // Globalus masyvas\nint top = 0;       // Globalus indeksas\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    char c;\n    init();\n\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas-ir-vykdymas","title":"Kompiliavimas ir Vykdymas","text":"<pre><code>gcc 01_n_usestack.c -o 01_n_usestack\n./01_n_usestack\n# Input: 123456\n# Output: 54321\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai","title":"\u2705 Privalumai","text":"<ul> <li>Paprastumas - viskas ai\u0161kiai matoma</li> <li>Greitas prototipavimas - lengva prad\u0117ti</li> <li>Joki\u0173 sud\u0117ting\u0173 koncept\u0173 - tinka mokymosi prad\u017eiai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Nelankstumas - tik vienas stekas</li> <li>Global\u016bs kintamieji - name pollution</li> <li>Sunku testuoti - viskas susimai\u0161\u0119</li> <li>Neperkeliamas kodas - sunku panaudoti kitur</li> </ul>"},{"location":"evolution/stack-evolution-1/#kada-naudoti","title":"\ud83c\udfaf Kada Naudoti","text":"<ul> <li>Labai ma\u017ei projektai</li> <li>Greitai prototipai</li> <li>Mokymosi tikslai</li> </ul>"},{"location":"evolution/stack-evolution-1/#2-etapas-failu-dekompozicija","title":"2 Etapas: Fail\u0173 Dekompozicija","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-fizinis-kodo-skaidymas","title":"Koncepcija: Fizinis Kodo Skaidymas","text":"<p>Pirmasis bandymas atskirti stekas nuo naudotojo kodo. \u010cia susiduriame su declarations vs definitions koncepcija.</p>"},{"location":"evolution/stack-evolution-1/#21-teisingas-variantas-02_n_stackc-02_n_userc","title":"2.1 Teisingas Variantas: <code>02_n_stack.c</code> + <code>02_n_user.c</code>","text":""},{"location":"evolution/stack-evolution-1/#stekas-02_n_stackc","title":"Stekas: <code>02_n_stack.c</code>","text":"<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-02_n_userc","title":"Naudotojas: <code>02_n_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"02_n_stack.c\"  // \u26a0\ufe0f \u012etraukiame .c fail\u0105!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas","title":"Kompiliavimas","text":"<pre><code>gcc 02_n_user.c -o 02_n_use_stack  # Veikia!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#22-klaidingas-variantas-02_nx_userc","title":"2.2 Klaidingas Variantas: <code>02_nx_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n// N\u0117ra joki\u0173 deklaracij\u0173!\n\nint main(void) {\n    char c;\n\n    init();        // \u274c Implicit declaration\n    // ... kitos funkcijos\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaidos","title":"Kompiliavimo Klaidos","text":"<pre><code>gcc 02_n_stack.c 02_nx_user.c -o 02_nx_use_stack\n\n# GCC Warning:\n02_nx_user.c:6:5: warning: implicit declaration of function 'init'\n\n# Clang Error:\n02_nx_user.c:6:5: error: call to undeclared function 'init'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Implicit Function Declarations - kai kompiliatorius nemato funkcijos deklaracijos, jis \"sp\u0117ja\" jos prototip\u0105. Tai pavojinga ir gali sukelti runtime klaidas!</p>"},{"location":"evolution/stack-evolution-1/#privalumai_1","title":"\u2705 Privalumai","text":"<ul> <li>Fizinis kodo atskyrimas</li> <li>Galima kompiliuoti atskirai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_1","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Vis dar global\u016bs kintamieji</li> <li>Neai\u0161ki s\u0105saja (interface)</li> <li>Include .c fail\u0173 yra blogas sprendimas</li> </ul>"},{"location":"evolution/stack-evolution-1/#3-etapas-moduliu-sistema","title":"3 Etapas: Moduli\u0173 Sistema","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-header-failai-ir-moduliai","title":"Koncepcija: Header Failai ir Moduliai","text":"<p>\u010cia \u012fvedame header failus (.h) ir mokam\u0117s declarations vs definitions skirtumo.</p>"},{"location":"evolution/stack-evolution-1/#31-klaidingas-variantas-03_nx_stackh-03_nx_stackc","title":"3.1 Klaidingas Variantas: <code>03_nx_stack.h</code> + <code>03_nx_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_nx_stackh","title":"Header: <code>03_nx_stack.h</code>","text":"<pre><code>#define SIZE 100\n\nchar stack[SIZE];  // \u274c Definition header faile!\nint top;           // \u274c Definition header faile!\n\nvoid init(void);   // \u2705 Declaration\nint isEmpty(void); // \u2705 Declaration\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 03_nx_stack.c 03_nx_user.c -o 03_nx_use_stack\n\n# Multiple definition error:\nmultiple definition of `stack'\nmultiple definition of `top'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_1","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Multiple Definition Error - kai tas pats simbolis apibr\u0117\u017eiamas keliose vietose. Header failai yra \u012ftraukiami \u012f kiekvien\u0105 .c fail\u0105, tod\u0117l definitions dubliuojasi!</p>"},{"location":"evolution/stack-evolution-1/#32-kitas-klaidingas-variantas-03_ny_stackh","title":"3.2 Kitas Klaidingas Variantas: <code>03_ny_stack.h</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_ny_stackh","title":"Header: <code>03_ny_stack.h</code>","text":"<pre><code>#define SIZE 100\n\nextern char stack[SIZE];  // \u2705 Declaration\nextern int top;           // \u2705 Declaration\n\nextern void init(void);   // \u2705 Declaration\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-03_ny_stackc","title":"Implementation: <code>03_ny_stack.c</code>","text":"<pre><code>#include \"03_ny_stack.h\"\n\n// \u274c N\u0117ra definitions!\n\nvoid init(void) {\n    top = 0;  // Naudojame neapibr\u0117\u017et\u0105 'top'\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_1","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 03_ny_stack.c 03_ny_user.c -o 03_ny_use_stack\n\n# Undefined reference error:\nundefined reference to `stack'\nundefined reference to `top'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_2","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Undefined Reference Error - <code>extern</code> sako \"\u0161is simbolis egzistuoja ka\u017ekur kitur\", bet jei jo niekur neapibr\u0117\u017eiame, linker negali jo rasti!</p>"},{"location":"evolution/stack-evolution-1/#33-teisingas-variantas-03_stackh-03_stackc","title":"3.3 Teisingas Variantas: <code>03_stack.h</code> + <code>03_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_stackh","title":"Header: <code>03_stack.h</code>","text":"<pre><code>// Tik declarations!\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-03_stackc","title":"Implementation: <code>03_stack.c</code>","text":"<pre><code>#include \"03_stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];  // \u2705 Definition implementation faile\nint top;           // \u2705 Definition implementation faile\n\nvoid init(void) {\n    top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-03_userc","title":"Naudotojas: <code>03_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"  // \u2705 Tik header\n\nint main(void) {\n    char c;\n    init();\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas_1","title":"Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_user.c -o 03_use_stack  # \u2705 Veikia!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_2","title":"\u2705 Privalumai","text":"<ul> <li>Ai\u0161ki s\u0105saja (header failas)</li> <li>Teisingas moduli\u0173 skaidymas</li> <li>Galima kompiliuoti atskirai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_2","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Vis dar global\u016bs kintamieji</li> <li>Galimos \"atakos\" (\u017er. <code>03_z_user.c</code>)</li> </ul>"},{"location":"evolution/stack-evolution-1/#4-etapas-informacijos-slepimas","title":"4 Etapas: Informacijos Sl\u0117pimas","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-static-raktazodis","title":"Koncepcija: <code>static</code> Rakta\u017eodis","text":"<p>Naudojame <code>static</code> rakta\u017eod\u012f, kad pasl\u0117ptume implementacijos detales nuo i\u0161orinio pasaulio.</p>"},{"location":"evolution/stack-evolution-1/#kodas-04_stackc","title":"Kodas: <code>04_stack.c</code>","text":"<pre><code>#include \"04_stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // \u2705 Internal linkage\nstatic int top;             // \u2705 Internal linkage\n\nstatic void reset(void) {   // \u2705 Private funkcija\n    top = 0;\n}\n\nvoid init(void) {           // \u2705 Public funkcija\n    top = 0;\n}\n\n// ... kitos public funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#header-04_stackh","title":"Header: <code>04_stack.h</code>","text":"<pre><code>// Tik public interface\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n// N\u0117ra reset() - ji private!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_3","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Static Storage Class - <code>static</code> global\u016bs kintamieji ir funkcijos yra matomi tik tame faile, kur apibr\u0117\u017eti. Tai C kalbos information hiding mechanizmas.</p>"},{"location":"evolution/stack-evolution-1/#atakos-bandymas-04_zx_userc","title":"Atakos Bandymas: <code>04_zx_user.c</code>","text":"<pre><code>#include \"04_stack.h\"\n\nextern char stack[];     // \u274c Bandome pasiekti\nextern int top;          // \u274c Bandome pasiekti\nextern void reset(void); // \u274c Bandome pasiekti\n\nint main(void) {\n    // ...\n    stack[top++] = '!';  // \u274c Ataka nepavyko!\n    reset();             // \u274c Ataka nepavyko!\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_2","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 04_stack.c 04_zx_user.c -o 04_zx_use_stack\n\n# Undefined reference errors:\nundefined reference to `stack'\nundefined reference to `top'\nundefined reference to `reset'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_3","title":"\u2705 Privalumai","text":"<ul> <li>Information hiding - implementacija pasl\u0117pta</li> <li>Saugumas - negalima tiesiogiai keisti duomen\u0173</li> <li>Moduliarumas - ai\u0161ki public/private riba</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_3","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Tik vienas stekas - static kintamieji yra global\u016bs modulio viduje</li> <li>Negalima kurti keli\u0173 egzempliori\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#5-etapas-vartotojo-apibreziamas-tipas","title":"5 Etapas: Vartotojo Apibr\u0117\u017eiamas Tipas","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-struct-ir-keliu-egzemplioriu-galimybe","title":"Koncepcija: <code>struct</code> ir Keli\u0173 Egzempliori\u0173 Galimyb\u0117","text":"<p>\u012evedame <code>struct Stack</code> tip\u0105, kuris leid\u017eia kurti kelis stekas.</p>"},{"location":"evolution/stack-evolution-1/#51-klaidingas-variantas-05_nx_usestackc","title":"5.1 Klaidingas Variantas: <code>05_nx_usestack.c</code>","text":"<pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Negalima!\n    static int top;           // \u274c Negalima!\n};\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_3","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 05_nx_usestack.c -o 05_nx_usestack\n\n# GCC:\nerror: expected specifier-qualifier-list before 'static'\n\n# Clang:\nerror: type name does not allow storage class to be specified\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_4","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Storage Class in Structs - C kalba draud\u017eia <code>static</code>, <code>extern</code>, <code>auto</code>, <code>register</code> specifikatorius strukt\u016bros nariams!</p>"},{"location":"evolution/stack-evolution-1/#52-kitas-klaidingas-variantas-05_ny_usestackc","title":"5.2 Kitas Klaidingas Variantas: <code>05_ny_usestack.c</code>","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u274c Funkcijos parametrai \"by value\"\nvoid init(struct Stack st) {\n    st.top = 0;  // Kei\u010dia tik kopij\u0105!\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;  // Kei\u010dia tik kopij\u0105!\n    }\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#vykdymo-rezultatas","title":"Vykdymo Rezultatas","text":"<pre><code>./05_ny_usestack\n123\n# Output: (tu\u0161\u010dia) - duomenys nepasikeit\u0117!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_5","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Pass by Value vs Pass by Reference - C kalboje strukt\u016bros perduodamos by value (kopijuojamos). Norint keisti original\u0105, reikia naudoti pointers!</p>"},{"location":"evolution/stack-evolution-1/#53-teisingas-variantas-05_n_usestackc","title":"5.3 Teisingas Variantas: <code>05_n_usestack.c</code>","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u2705 Naudojame pointers\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nint main(void) {\n    struct Stack st1, st2;  // \u2705 Du atskiri stekai!\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    // ... naudojame st1\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    // ... naudojame st2\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_4","title":"\u2705 Privalumai","text":"<ul> <li>Keli egzemplioriai - galima kurti daug stek\u0173</li> <li>Type safety - ai\u0161kus duomen\u0173 tipas</li> <li>Lokal\u016bs duomenys - kiekvienas stekas turi savo duomenis</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_4","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Atskleid\u017eiama strukt\u016bra - galimos atakos</li> <li>Reikia modulio - geriau atskirti \u012f failus</li> </ul>"},{"location":"evolution/stack-evolution-1/#6-etapas-tipas-modulyje","title":"6 Etapas: Tipas Modulyje","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-strukturos-tipas-atskirame-module","title":"Koncepcija: Strukt\u016bros Tipas Atskirame Module","text":"<p>Perkeliame <code>struct Stack</code> \u012f atskir\u0105 modul\u012f, bet strukt\u016bros nariai vis dar matomi.</p>"},{"location":"evolution/stack-evolution-1/#header-06_stackh","title":"Header: <code>06_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack {          // \u2705 Public strukt\u016bra\n    char stack[SIZE];   // \u274c Matomi nariai\n    int top;            // \u274c Matomi nariai\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-06_stackc","title":"Implementation: <code>06_stack.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nstatic void reset(struct Stack *pst) {  // \u2705 Private funkcija\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-06_userc","title":"Naudotojas: <code>06_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;\n\n    // Naudojame per interface\n    init(&amp;st1);\n    push(&amp;st1, 'A');\n\n    // Bet galime ir tiesiogiai!\n    st1.stack[st1.top++] = 'B';  // \u2705 Veikia, bet blogai!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#atakos-demonstracija-06_z_userc","title":"Atakos Demonstracija: <code>06_z_user.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st2;\n\n    init(&amp;st2);\n    push(&amp;st2, '1');\n    push(&amp;st2, '2');\n    push(&amp;st2, '3');\n\n    st2.stack[st2.top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    // Output: !321\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_5","title":"\u2705 Privalumai","text":"<ul> <li>Modulinis dizainas</li> <li>Keli egzemplioriai</li> <li>Ai\u0161ki s\u0105saja</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_5","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Strukt\u016bros nariai matomi - galimos atakos</li> <li>N\u0117ra tikros inkapsuliacija</li> </ul>"},{"location":"evolution/stack-evolution-1/#7-etapas-pilna-inkapsuliacija","title":"7 Etapas: Pilna Inkapsuliacija","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-forward-declaration-ir-opaque-pointers","title":"Koncepcija: Forward Declaration ir Opaque Pointers","text":"<p>Naudojame forward declaration ir opaque pointers, kad visi\u0161kai pasl\u0117ptume strukt\u016bros implementacij\u0105.</p>"},{"location":"evolution/stack-evolution-1/#71-klaidingi-variantai","title":"7.1 Klaidingi Variantai","text":""},{"location":"evolution/stack-evolution-1/#bandymas-1-07_nx_userc","title":"Bandymas 1: <code>07_nx_user.c</code>","text":"<pre><code>#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;  // \u274c Incomplete type!\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_4","title":"Kompiliavimo Klaida","text":"<pre><code># GCC:\nerror: storage size of 'st1' isn't known\n\n# Clang:\nerror: variable has incomplete type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#bandymas-2-07_ny_userc","title":"Bandymas 2: <code>07_ny_user.c</code>","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n\n    pst1 = calloc(sizeof(struct Stack), 1);  // \u274c Incomplete type!\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_5","title":"Kompiliavimo Klaida","text":"<pre><code>error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_6","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Incomplete Types - kai turime tik forward declaration (<code>struct Stack;</code>), negalime: - Kurti kintam\u0173j\u0173 to tipo - Naudoti <code>sizeof</code> - Pasiekti nari\u0173</p> <p>Bet galime kurti pointers \u012f t\u0105 tip\u0105!</p>"},{"location":"evolution/stack-evolution-1/#72-teisingas-variantas-07_stackh-07_stackc","title":"7.2 Teisingas Variantas: <code>07_stack.h</code> + <code>07_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-07_stackh","title":"Header: <code>07_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack;  // \u2705 Forward declaration (opaque type)\n\nstruct Stack* create(void);     // \u2705 Factory funkcija\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-07_stackc","title":"Implementation: <code>07_stack.c</code>","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include \"07_stack.h\"\n\nstruct Stack {              // \u2705 Tikroji definicija (pasl\u0117pta)\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {  // \u2705 Private\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-07_userc","title":"Naudotojas: <code>07_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n\n    pst1 = create();  // \u2705 Naudojame factory\n\n    init(pst1);\n    push(pst1, '1');\n    push(pst1, '2');\n    push(pst1, '3');\n\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#atakos-bandymas-07_zx_userc","title":"Atakos Bandymas: <code>07_zx_user.c</code>","text":"<pre><code>#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1 = create();\n\n    init(pst1);\n    push(pst1, '1');\n\n    pst1-&gt;stack[pst1-&gt;top++] = '!';  // \u274c Ataka nepavyko!\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_6","title":"Kompiliavimo Klaida","text":"<pre><code># GCC:\nerror: invalid use of undefined type 'struct Stack'\n\n# Clang:\nerror: incomplete definition of type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#73-pilnas-variantas-su-destroy-077_stackh","title":"7.3 Pilnas Variantas su <code>destroy()</code>: <code>077_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid destroy(struct Stack *);    // \u2705 Memory management\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_6","title":"\u2705 Privalumai","text":"<ul> <li>Pilna inkapsuliacija - strukt\u016bra visi\u0161kai pasl\u0117pta</li> <li>Saugumas - ne\u012fmanomos atakos</li> <li>Lankstumas - galima keisti implementacij\u0105</li> <li>Memory management - kontroliuojamas objekt\u0173 gyvavimo ciklas</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_6","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Sud\u0117tingumas - reikia factory funkcij\u0173</li> <li>Heap allocation - dinaminis atminties valdymas</li> <li>Performance overhead - pointer indirection</li> </ul>"},{"location":"evolution/stack-evolution-1/#tipines-klaidos-ir-ju-sprendimas","title":"Tipin\u0117s Klaidos ir J\u0173 Sprendimas","text":""},{"location":"evolution/stack-evolution-1/#1-implicit-function-declarations","title":"1. Implicit Function Declarations","text":""},{"location":"evolution/stack-evolution-1/#problema","title":"\u274c Problema","text":"<pre><code>// N\u0117ra #include arba deklaracijos\nint main(void) {\n    init();  // Compiler \"sp\u0117ja\" prototip\u0105\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas","title":"\u2705 Sprendimas","text":"<pre><code>#include \"stack.h\"  // Arba\nvoid init(void);    // Explicit declaration\n\nint main(void) {\n    init();  // Dabar OK\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-multiple-definition-errors","title":"2. Multiple Definition Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_1","title":"\u274c Problema","text":"<pre><code>// header.h\nint global_var = 42;  // Definition header faile!\n\n// file1.c\n#include \"header.h\"   // \u012etraukia definition\n\n// file2.c  \n#include \"header.h\"   // Dar kart\u0105 \u012ftraukia definition\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_1","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// implementation.c\nint global_var = 42;    // Definition tik vienoje vietoje\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-undefined-reference-errors","title":"3. Undefined Reference Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_2","title":"\u274c Problema","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// Bet niekur n\u0117ra definition!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_2","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// implementation.c\nint global_var = 42;    // Definition\n</code></pre>"},{"location":"evolution/stack-evolution-1/#4-pass-by-value-klaidos","title":"4. Pass by Value Klaidos","text":""},{"location":"evolution/stack-evolution-1/#problema_3","title":"\u274c Problema","text":"<pre><code>void modify(struct Data data) {\n    data.value = 100;  // Kei\u010dia tik kopij\u0105!\n}\n\nint main(void) {\n    struct Data d = {0};\n    modify(d);\n    printf(\"%d\\n\", d.value);  // Vis dar 0!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_3","title":"\u2705 Sprendimas","text":"<pre><code>void modify(struct Data *data) {\n    data-&gt;value = 100;  // Kei\u010dia original\u0105\n}\n\nint main(void) {\n    struct Data d = {0};\n    modify(&amp;d);\n    printf(\"%d\\n\", d.value);  // Dabar 100!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#5-incomplete-type-errors","title":"5. Incomplete Type Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_4","title":"\u274c Problema","text":"<pre><code>// header.h\nstruct Stack;  // Forward declaration\n\n// user.c\nstruct Stack st;  // Negalima - incomplete type!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_4","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nstruct Stack;\nstruct Stack* create(void);  // Factory funkcija\n\n// user.c\nstruct Stack *pst = create();  // Pointer OK!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#ataku-demonstracijos","title":"Atak\u0173 Demonstracijos","text":""},{"location":"evolution/stack-evolution-1/#1-globaliu-kintamuju-ataka-3-etapas","title":"1. Globali\u0173 Kintam\u0173j\u0173 Ataka (3 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-kodas-03_z_userc","title":"Atakos kodas: <code>03_z_user.c</code>","text":"<pre><code>#include \"03_stack.h\"\n\nextern char stack[];  // Pasiekiame global\u0173 kintam\u0105j\u012f\nextern int top;\n\nint main(void) {\n    init();\n    push('1'); push('2'); push('3');\n\n    stack[top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty()) putchar(pop());\n    // Output: !321 (vietoj 321)\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-strukturos-nariu-ataka-6-etapas","title":"2. Strukt\u016bros Nari\u0173 Ataka (6 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-kodas-06_z_userc","title":"Atakos kodas: <code>06_z_user.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st;\n\n    init(&amp;st);\n    push(&amp;st, '1'); push(&amp;st, '2'); push(&amp;st, '3');\n\n    st.stack[st.top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty(&amp;st)) putchar(pop(&amp;st));\n    // Output: !321\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-nepavykusi-ataka-7-etapas","title":"3. Nepavykusi Ataka (7 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-bandymas-07_zx_userc_1","title":"Atakos bandymas: <code>07_zx_user.c</code>","text":"<pre><code>#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst = create();\n\n    init(pst);\n    push(pst, '1');\n\n    pst-&gt;stack[pst-&gt;top++] = '!';  // \u274c Ataka nepavyko!\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_7","title":"Kompiliavimo klaida","text":"<pre><code>error: incomplete definition of type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pamoka","title":"\ud83d\udd0d Pamoka","text":"<p>Inkapsuliacija veikia! - 7 etape strukt\u016bros implementacija yra visi\u0161kai pasl\u0117pta, tod\u0117l jokie \"hack'ai\" neveiks.</p>"},{"location":"evolution/stack-evolution-1/#praktiniai-patarimai","title":"Praktiniai Patarimai","text":""},{"location":"evolution/stack-evolution-1/#1-kompiliavimo-strategijos","title":"1. Kompiliavimo Strategijos","text":""},{"location":"evolution/stack-evolution-1/#atskirai-kompiliavimas","title":"Atskirai Kompiliavimas","text":"<pre><code># Kompiliuojame \u012f object failus\ngcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\n\n# Linkuojame\ngcc stack.o user.o -o program\n</code></pre>"},{"location":"evolution/stack-evolution-1/#makefile-pavyzdys","title":"Makefile Pavyzdys","text":"<pre><code>CC = gcc\nCFLAGS = -Wall -Wextra -std=c99\n\nprogram: stack.o user.o\n    $(CC) stack.o user.o -o program\n\nstack.o: stack.c stack.h\n    $(CC) $(CFLAGS) -c stack.c\n\nuser.o: user.c stack.h\n    $(CC) $(CFLAGS) -c user.c\n\nclean:\n    rm -f *.o program\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-header-guardai","title":"2. Header Guard'ai","text":"<pre><code>#ifndef STACK_H\n#define STACK_H\n\n// Header turinys\n\n#endif /* STACK_H */\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-const-correctness","title":"3. Const Correctness","text":"<pre><code>// Funkcijos, kurios nekei\u010dia duomen\u0173\nint isEmpty(const struct Stack *pst);\nint isFull(const struct Stack *pst);\nchar peek(const struct Stack *pst);  // \u017di\u016bri be pop\n</code></pre>"},{"location":"evolution/stack-evolution-1/#4-error-handling","title":"4. Error Handling","text":"<pre><code>typedef enum {\n    STACK_OK,\n    STACK_EMPTY,\n    STACK_FULL,\n    STACK_NULL_POINTER\n} StackResult;\n\nStackResult push(struct Stack *pst, char c) {\n    if (!pst) return STACK_NULL_POINTER;\n    if (isFull(pst)) return STACK_FULL;\n\n    pst-&gt;stack[pst-&gt;top++] = c;\n    return STACK_OK;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#5-memory-management","title":"5. Memory Management","text":"<pre><code>// Visada poruokite create/destroy\nstruct Stack *pst = create();\nif (pst) {\n    // Naudojame...\n    destroy(pst);  // Nepamir\u0161kite!\n    pst = NULL;    // Apsauga nuo dangling pointer\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#santrauka-ir-isvados","title":"Santrauka ir I\u0161vados","text":""},{"location":"evolution/stack-evolution-1/#evoliucijos-etapu-santrauka","title":"Evoliucijos Etap\u0173 Santrauka","text":"Etapas Sprendimas Privalumai Tr\u016bkumai Saugumas 1 Monolitin\u0117 programa Paprastumas Nelankstumas \u274c Jokio 2 Fail\u0173 dekompozicija Fizinis skaidymas Global\u016bs kintamieji \u274c Jokio 3 Moduli\u0173 sistema Ai\u0161ki s\u0105saja Global\u016bs kintamieji \u274c Atakos galimos 4 Information hiding Pasl\u0117pta implementacija Tik vienas egzempliorius \u26a0\ufe0f Dalinis 5 Vartotojo tipas Keli egzemplioriai Atskleid\u017eiama strukt\u016bra \u274c Atakos galimos 6 Tipas modulyje Modulinis dizainas Matomi nariai \u274c Atakos galimos 7 Pilna inkapsuliacija Visi\u0161kas saugumas Sud\u0117tingumas \u2705 Pilnas"},{"location":"evolution/stack-evolution-1/#pagrindiniai-principai","title":"Pagrindiniai Principai","text":""},{"location":"evolution/stack-evolution-1/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<ul> <li>Atskirti interface nuo implementation</li> <li>Atskirti public nuo private</li> <li>Atskirti data nuo behavior</li> </ul>"},{"location":"evolution/stack-evolution-1/#2-information-hiding","title":"2. Information Hiding","text":"<ul> <li>Sl\u0117pti implementacijos detales</li> <li>Atskleid\u017eiami tik b\u016btini elementai</li> <li>Naudoti <code>static</code> ir opaque pointers</li> </ul>"},{"location":"evolution/stack-evolution-1/#3-type-safety","title":"3. Type Safety","text":"<ul> <li>Naudoti strukt\u016bras vietoj primityvi\u0173 tip\u0173</li> <li>Ai\u0161k\u016bs funkcij\u0173 prototipai</li> <li>Const correctness</li> </ul>"},{"location":"evolution/stack-evolution-1/#4-memory-management","title":"4. Memory Management","text":"<ul> <li>Ai\u0161kus objekt\u0173 gyvavimo ciklas</li> <li>Factory funkcijos k\u016brimui</li> <li>Destructor funkcijos sunaikinimui</li> </ul>"},{"location":"evolution/stack-evolution-1/#kada-naudoti-kuri-etapa","title":"Kada Naudoti Kur\u012f Etap\u0105?","text":""},{"location":"evolution/stack-evolution-1/#etapai-1-2-mokymasis-ir-prototipai","title":"Etapai 1-2: Mokymasis ir Prototipai","text":"<ul> <li>Greitai eksperimentai</li> <li>Labai ma\u017ei projektai</li> <li>Algoritmo testavimas</li> </ul>"},{"location":"evolution/stack-evolution-1/#etapai-3-4-mazi-projektai","title":"Etapai 3-4: Ma\u017ei Projektai","text":"<ul> <li>Vienas programuotojas</li> <li>Paprastos duomen\u0173 strukt\u016bros</li> <li>Nereikia keli\u0173 egzempliori\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#etapai-5-6-vidutiniai-projektai","title":"Etapai 5-6: Vidutiniai Projektai","text":"<ul> <li>Reikia keli\u0173 egzempliori\u0173</li> <li>Komandinis darbas</li> <li>Modulinis dizainas</li> </ul>"},{"location":"evolution/stack-evolution-1/#7-etapas-dideli-projektai","title":"7 Etapas: Dideli Projektai","text":"<ul> <li>Bibliotek\u0173 k\u016brimas</li> <li>Maksimalus saugumas</li> <li>API dizainas</li> <li>Ilgalaikis palaikymas</li> </ul>"},{"location":"evolution/stack-evolution-1/#kelias-i-c","title":"Kelias \u012f C++","text":"<p>\u0160ie C kalbos principai tiesiogiai veda \u012f C++ koncepcijas:</p> <pre><code>// C (7 etapas)\nstruct Stack* create(void);\nvoid destroy(struct Stack*);\nvoid push(struct Stack*, char);\n\n// C++ (klas\u0117s)\nclass Stack {\npublic:\n    Stack();           // Constructor\n    ~Stack();          // Destructor\n    void push(char);   // Method\nprivate:\n    char stack[SIZE];  // Private members\n    int top;\n};\n</code></pre>"},{"location":"evolution/stack-evolution-1/#galutine-isvada","title":"\ud83c\udfaf Galutin\u0117 I\u0161vada","text":"<p>ADT evoliucija parodo, kaip programavimo kalbos ir paradigmos vyst\u0117si sprend\u017eiant realias problemas. Kiekvienas etapas atskleid\u017eia nauj\u0105 problem\u0105 ir jos sprendim\u0105, vedant\u012f link moderni\u0173 objektinio programavimo princip\u0173.</p> <p>Svarbiausias takeaway: Suprasti kod\u0117l tam tikri sprendimai yra geresni, o ne tik kaip juos implementuoti. Tai pad\u0117s jums priimti geresnius dizaino sprendimus ateityje!</p>"},{"location":"evolution/stack-evolution-1/#klausimu-ir-uzduociu-pavyzdziai","title":"Klausim\u0173 ir U\u017eduo\u010di\u0173 Pavyzd\u017eiai","text":""},{"location":"evolution/stack-evolution-1/#diskusijos-klausimai","title":"\ud83e\udd14 Diskusijos Klausimai","text":"<ol> <li>Kod\u0117l <code>static</code> kintamieji 4 etape neleid\u017eia kurti keli\u0173 stek\u0173?</li> <li>Kuo skiriasi \"declaration\" nuo \"definition\"?</li> <li>Kod\u0117l forward declaration leid\u017eia kurti pointers, bet ne variables?</li> <li>Kaip opaque pointers padeda u\u017etikrinti API stabilum\u0105?</li> </ol>"},{"location":"evolution/stack-evolution-1/#praktines-uzduotys","title":"\ud83d\udcbb Praktin\u0117s U\u017eduotys","text":"<ol> <li>Implementuokite Queue ADT naudodami 7 etap\u0105</li> <li>Sukurkite Dynamic Array su automatic resizing</li> <li>Padarykite Stack thread-safe naudodami mutex</li> <li>Implementuokite Generic Stack naudodami void pointers</li> </ol>"},{"location":"evolution/stack-evolution-1/#kodo-analizes-uzduotys","title":"\ud83d\udd0d Kodo Analiz\u0117s U\u017eduotys","text":"<ol> <li>Raskite klaidas pateiktuose kodo fragmentuose</li> <li>Paai\u0161kinkite, kod\u0117l tam tikri kompiliavimo bandymai nepavyko</li> <li>Pasi\u016blykite, kaip pagerinti duot\u0105 implementacij\u0105</li> </ol> <p>S\u0117km\u0117s mokantis! \ud83d\ude80</p>"}]}